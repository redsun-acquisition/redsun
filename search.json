{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Redsun","text":"","path":["Redsun"],"tags":[]},{"location":"#redsun","level":1,"title":"Redsun","text":"<p>Event-driven data acquisition software for scientific applications</p> <p>Warning</p> <p>This project is currently under active development and it may (and most likely will) receive breaking changes. Use at your own risk.</p> <p>Redsun is an acquisition software written in CPython, with the concept of building modular user interfaces for scientific data acquisition.</p> <p>It leverages the Bluesky ecosystem to provide a flexible, hardware-agnostic and unopinionated framework for building a control software tailored to the specific needs of different users in different scientific fields.</p> <p>The philosophy of Redsun is to:</p> <ul> <li>not \"reinvent the wheel\", but rather \"ship the tools to build the wheel\";</li> <li>be extensible and modular: pick only the tools you need to get the job done;</li> <li>give the control of your data (and metadata) to you: you decide what is what.</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting started","text":"<ul> <li> <p>Tutorials</p> <p>Learn Redsun from the ground up with step-by-step lessons</p> <p>Start learning </p> </li> <li> <p>How-to guides</p> <p>Practical guides for common tasks and problems</p> <p>Browse guides </p> </li> <li> <p>Reference</p> <p>Technical documentation and API reference</p> <p>View reference </p> </li> <li> <p>Explanation</p> <p>Understand the concepts and design behind Redsun</p> <p>Read explanations </p> </li> </ul>","path":["Redsun"],"tags":[]},{"location":"#quick-links","level":2,"title":"Quick links","text":"<ul> <li>Installation guide</li> <li>Statement of need</li> <li>API reference</li> <li>Changelog</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#about-the-documentation","level":2,"title":"About the documentation","text":"<p>This documentation follows the Diataxis framework, organizing content into four distinct categories based on your needs:</p> <ul> <li>Tutorials are learning-oriented lessons</li> <li>How-to guides are task-oriented recipes</li> <li>Reference is information-oriented technical descriptions</li> <li>Explanation is understanding-oriented discussions</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#project-links","level":2,"title":"Project links","text":"<ul> <li>GitHub repository</li> <li>PyPI package</li> <li><code>sunflare</code> repository</li> </ul>","path":["Redsun"],"tags":[]},{"location":"explanation/","level":1,"title":"Explanation","text":"<ul> <li>Statement of need</li> </ul>","path":["Explanation"],"tags":[]},{"location":"explanation/#architecture-design","level":2,"title":"Architecture &amp; design","text":"<ul> <li>Container architecture</li> <li>Component system</li> </ul>","path":["Explanation"],"tags":[]},{"location":"explanation/component-system/","level":1,"title":"Component system","text":"<p><code>redsun</code> component system allows third-party packages to provide devices, presenters, and views that are dynamically discovered and loaded at runtime.</p>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#overview","level":2,"title":"Overview","text":"<p>From Python point of view, components are standard Python packages that register themselves via entry points. When <code>redsun</code> builds an application from a YAML configuration file, it uses these entry points to discover available plugins and load the requested components.</p> <pre><code>graph TB\n    Config[YAML config] --&gt;|references| Plugins\n    Plugins --&gt;|discovered via| EntryPoints[entry points]\n    EntryPoints --&gt;|load| Manifest[plugin manifest]\n    Manifest --&gt;|resolves to| Classes[component classes]\n    Classes --&gt;|registered in| Container[AppContainer]</code></pre>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#plugin-discovery","level":2,"title":"Plugin discovery","text":"<p>When <code>AppContainer.from_config()</code> is called with a configuration file, Redsun:</p> <ol> <li>Reads the configuration - parses the YAML file to determine which devices, presenters, and views are needed.</li> <li>Queries entry points - looks up installed packages registered under the <code>redsun.plugins</code> entry point group.</li> <li>Loads manifests - each plugin provides a YAML manifest file that maps plugin IDs to their Python class locations.</li> <li>Validates protocols - each loaded class is checked against the expected protocol (<code>Device</code>, <code>Presenter</code>, or <code>View</code>).</li> <li>Creates the container - a dynamic container class is assembled with the discovered components.</li> </ol>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#component-manifest","level":2,"title":"Component manifest","text":"<p>Each component package must include a YAML manifest file named <code>redsun.yaml</code> that declares the available components. </p> <p>Each entry maps a plugin ID directly to its <code>\"module:ClassName\"</code> class path:</p> <pre><code># redsun.yaml\n\ndevices:\n  my_motor: \"my_plugin.devices:MyMotor\"\n\npresenters:\n  my_controller: \"my_plugin.presenters:MyController\"\n\nviews:\n  my_ui: \"my_plugin.views:MyView\"\n</code></pre> <p>The manifest must be registered as a Python entry point in the package <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"redsun.plugins\"]\nmy-plugin = \"redsun.yaml\"\n</code></pre> <p>Tip</p> <p>This is inspired by the napari manifest.</p> <p>Make sure that depending on the packaging system you use, the <code>redsun.yaml</code> is included in the built package otherwise your components will not be discoverable.</p>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#configuration-file-format","level":2,"title":"Configuration file format","text":"<p>The application configuration file references plugins by name and ID. A full example follows:</p> <pre><code>schema_version: 1.0\nsession: \"My application\"\nfrontend: \"pyqt\"\nmetadata:\n    user: Jacopo Abramo\n    location: Jena\n    setup: iSCAT\n\ndevices:\n  motor:\n    plugin_name: my-plugin\n    plugin_id: my_motor\n    axis:\n      - X\n      - Y\n\npresenters:\n  controller:\n    plugin_name: my-plugin\n    plugin_id: my_controller\n\nviews:\n  ui:\n    plugin_name: my-plugin\n    plugin_id: my_ui\n</code></pre> <p>The top-level keys represent application level information:</p> <ul> <li><code>schema_version</code> is the version value of the component system, kept for future compatibility;</li> <li><code>session</code> is the name which will be assigned to the application for display;</li> <li><code>frontend</code> is the UI toolkit used to load the correct subclass of <code>AppContainer</code>;</li> <li><code>metadata</code> are application-level metadata to add contextual informations.</li> </ul> <p>The <code>plugin_name</code> and <code>plugin_id</code> keys are used for plugin resolution and are not passed to the component constructors. All other keys become keyword arguments for the component.</p>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#protocol-validation","level":2,"title":"Protocol validation","text":"<p>Before a plugin class is used, <code>redsun</code> verifies it implements the expected protocol:</p> <ul> <li>Devices must be subclasses of <code>Device</code> or structurally implement the <code>PDevice</code> protocol.</li> <li>Presenters must be subclasses of <code>Presenter</code> or structurally implement the <code>PPresenter</code> protocol.</li> <li>Views must be subclasses of <code>View</code> or structurally implement the <code>PView</code> protocol.</li> </ul> <p>Classes that satisfy the protocol structurally (without inheriting from the base class) are registered as virtual subclasses via <code>ABCMeta.register()</code>.</p>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/component-system/#inline-vs-config-based-registration","level":2,"title":"Inline vs. config-based registration","text":"<p>The plugin system is used when building from configuration files via <code>AppContainer.from_config()</code>. When using the declarative class-based approach (defining a container subclass with <code>device()</code>, <code>presenter()</code> or <code>view()</code> field functions), component classes are passed directly as the first argument to the respective function and do not go through plugin discovery.</p> <p>Both approaches produce the same result: an <code>AppContainer</code> with registered device, presenter, and view components ready to be built.</p>","path":["Explanation","Component system"],"tags":[]},{"location":"explanation/container-architecture/","level":1,"title":"Container architecture","text":"<p><code>redsun</code> leverages an architectural denominated to the Device-View-Presenter (<code>DVP</code>). This is semantically close to the definition of the Model-View-Presenter (<code>MVP</code>) architecture.</p> Architecture block diagram <pre><code>block-beta\n  columns 6\n\n  V1[\"View A\"]:2\n  V2[\"View B\"]:2\n  V3[\"View C\"]:2\n  VC[\"VirtualContainer\"]:6\n  P1[\"Presenter A\"]:3\n  P2[\"Presenter B\"]:3\n  D1[\"Device A\"]:2\n  D2[\"Device B\"]:2\n  D3[\"Device C\"]:2\n\n  style V1 fill:#4caf50,color:#fff,stroke:#388e3c\n  style V2 fill:#4caf50,color:#fff,stroke:#388e3c\n  style V3 fill:#4caf50,color:#fff,stroke:#388e3c\n  style VC fill:#ffc107,color:#000,stroke:#f9a825\n  style P1 fill:#f44336,color:#fff,stroke:#c62828\n  style P2 fill:#f44336,color:#fff,stroke:#c62828\n  style D1 fill:#2196f3,color:#fff,stroke:#1565c0\n  style D2 fill:#2196f3,color:#fff,stroke:#1565c0\n  style D3 fill:#2196f3,color:#fff,stroke:#1565c0</code></pre> <p>The key differences in respect to the <code>MVP</code> architecture are the following:</p> <ul> <li>In <code>MVP</code>, the Model layer represents the data the application holds; think for example of a text editor: the content of the text is stored in this layer.</li> <li>In contrast, the Device layer assumes the role of containing all objects interfacing with real hardware; it is both a semantic and pragmatic difference which, to avoid confusion, has been applied in the renaming of the architecture to make the distinction explicit.</li> <li>Additionally, in the <code>MVP</code> pattern, Presenters and Views are tightly coupled between each other, making it difficult to have one without the other. In <code>DVP</code>, both layers are decoupled via a virtual container to follow an approach of dependency injection in order to maintain all the components separated, allowing to bring only the pieces you need to create an application fully compliant with your specifications.</li> </ul>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#overview","level":2,"title":"Overview","text":"<p>At the core of Redsun is the <code>AppContainer</code>, which acts as the central registry and build system for all application components. Components are declared as class attributes and instantiated in a well-defined dependency order.</p> <p>Build order — components are constructed in strict dependency sequence:</p> <pre><code>graph LR\n    VC[VirtualContainer]\n    Devices\n    Presenters\n    Views\n\n    VC --&gt; Devices\n    Devices --&gt; Presenters\n    Presenters --&gt; Views</code></pre> <p>Provider registration and dependency injection — once all components are built, any presenter or view implementing the relevant protocol participates in registration and injection:</p> <pre><code>graph LR\n    VC[VirtualContainer]\n\n    subgraph Presenters\n        P1[Presenter A]\n        P2[Presenter B]\n    end\n\n    subgraph Views\n        V1[View A]\n        V2[View B]\n    end\n\n    P1 -.-&gt;|IsProvider: register_providers| VC\n    V1 -.-&gt;|IsProvider: register_providers| VC\n    VC -.-&gt;|IsInjectable: inject_dependencies| P2\n    VC -.-&gt;|IsInjectable: inject_dependencies| V2</code></pre>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#the-dvp-pattern","level":2,"title":"The DVP pattern","text":"<p><code>redsun</code> builds components using reusable patterns provided by <code>sunflare</code>:</p> <ul> <li>Devices: objects interfacing with real hardware components that implement Bluesky's device protocols via <code>Device</code>.</li> <li>View: UI components that implement <code>View</code> to display data and capture user interactions.</li> <li>Presenter: business logic components that implement <code>Presenter</code>, sitting between models and views, coordinating device operations and updating the UI through <code>psygnal</code>.</li> </ul> <p>This separation ensures that hardware drivers, UI components, and business logic can be developed and tested independently.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#declarative-containers","level":2,"title":"Declarative containers","text":"<p><code>redsun</code> operates on a bring-your-own components approach. Each component is intended to be developed separately and in isolation or as part of bundles of multiple components that can be dynamically assembled. In a declarative manner, this means importing the components explicitly and assigning them to a container.</p> <p>Components are declared as class attributes using the layer-specific field specifiers: <code>device()</code>, <code>presenter()</code>, and <code>view()</code>. Each accepts the component class as its first positional argument, followed by optional keyword arguments forwarded to the constructor.</p> <p>When writing a container explicitly, you inherit from the frontend-specific subclass rather than the base <code>AppContainer</code> — for Qt applications that is <code>QtAppContainer</code>:</p> <pre><code>from redsun.containers import device, presenter, view\nfrom redsun.qt import QtAppContainer\n\n\ndef my_app() -&gt; None:\n    class MyApp(QtAppContainer):\n        motor = device(MyMotor, axis=[\"X\", \"Y\"])\n        ctrl = presenter(MyController, gain=1.0)\n        ui = view(MyView)\n\n    MyApp().run()\n</code></pre> <p>The class is defined inside a function so that the Qt imports and any heavy device imports are deferred until the application is actually launched.</p> <p>The <code>AppContainerMeta</code> metaclass collects these declarations at class creation time. Because the class is passed directly to the field specifier, no annotation inspection is needed. This declarative approach allows the container to:</p> <ul> <li>validate component types at class creation time;</li> <li>inherit and override components from base classes;</li> <li>merge configuration from YAML files with inline keyword arguments.</li> </ul>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#component-naming","level":2,"title":"Component naming","text":"<p>Every component receives a <code>name</code> that is used as its key in the container's <code>devices</code>, <code>presenters</code>, or <code>views</code> dictionaries and passed as the first positional argument to the component constructor. The name is resolved with the following priority:</p> <ol> <li><code>alias</code> — if an explicit <code>alias</code> is passed to <code>device()</code>, <code>presenter()</code>, or <code>view()</code>, that value is used regardless of everything else.</li> <li>attribute name — in the declarative flow, the Python attribute name becomes the component name when no <code>alias</code> is provided.</li> <li>YAML key — in the dynamic flow (<code>from_config()</code>), the top-level key in the <code>devices</code>/<code>presenters</code>/<code>views</code> section of the configuration file becomes the component name.</li> </ol> <p>Examples in the declarative flow:</p> <pre><code>class MyApp(QtAppContainer):\n    motor = device(MyMotor)                       # name → \"motor\"\n    cam = device(MyCamera, alias=\"detector\")      # name → \"detector\"\n</code></pre> <p>In the dynamic flow:</p> <pre><code>devices:\n  iSCAT channel:           # name → \"iSCAT channel\"\n    plugin_name: my-plugin\n    plugin_id: my_detector\n</code></pre>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#configuration-file-support","level":2,"title":"Configuration file support","text":"<p>Components can pull their keyword arguments from a YAML configuration file by passing <code>config=</code> to the class definition and <code>from_config=</code> to each field specifier call:</p> <pre><code>from redsun.containers import device, presenter, view\nfrom redsun.qt import QtAppContainer\n\n\ndef my_app() -&gt; None:\n    class MyApp(QtAppContainer, config=\"app_config.yaml\"):\n        motor = device(MyMotor, from_config=\"motor\")\n        ctrl = presenter(MyController, from_config=\"ctrl\")\n        ui = view(MyView, from_config=\"ui\")\n\n    MyApp().run()\n\n    # alternatively, you can first build and then run the app\n    app = MyApp()\n    app.build()\n    app.run()\n</code></pre> <p>The configuration file provides base keyword arguments for each component. These can be selectively overridden by inline keyword arguments in the field specifier call, allowing the same container class to be reused across different hardware setups by swapping configuration files.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#build-order","level":2,"title":"Build order","text":"<p>When <code>build()</code> is called, the container proceeds in three phases:</p> <p>Phase 1 — construction:</p> <ol> <li><code>VirtualContainer</code> — created and seeded with the application configuration.</li> <li>Devices — each receives its resolved name and keyword arguments.</li> <li>Presenters — each receives its resolved name and the full device dictionary.</li> <li>Views — each receives its resolved name.</li> </ol> <p>Phase 2 — provider registration:</p> <p>Any presenter or view implementing <code>IsProvider</code> calls <code>register_providers()</code> on the <code>VirtualContainer</code>. This is safe to run across both layers simultaneously because no injection occurs here.</p> <p>Phase 3 — dependency injection:</p> <p>Any presenter or view implementing <code>IsInjectable</code> calls <code>inject_dependencies()</code> on the <code>VirtualContainer</code>, consuming providers registered in phase 2.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#communication","level":2,"title":"Communication","text":"<p>Components communicate through the <code>VirtualContainer</code>, which serves as the single shared data exchange layer for the application. It combines two roles:</p> <ul> <li>Signal registry: components can register their <code>psygnal</code> signals into the container via <code>register_signals()</code>, making them discoverable by other components without direct references to each other. Registered signals are accessible through the <code>signals</code> property.</li> <li>Dependency injection: built on top of <code>dependency_injector</code>'s <code>DynamicContainer</code>, it allows any presenter or view implementing <code>IsProvider</code> to register typed providers, and any presenter or view implementing <code>IsInjectable</code> to consume them. This enables components across both layers to share information without direct coupling.</li> </ul> <p>The <code>VirtualContainer</code> is created during <code>build()</code> and is accessible via the <code>virtual_container</code> property after the container is built.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#two-usage-flows","level":2,"title":"Two usage flows","text":"<p><code>redsun</code> supports two distinct approaches for assembling an application, both producing the same result at runtime.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#explicit-flow-developer-written-containers","level":3,"title":"Explicit flow (developer-written containers)","text":"<p>The explicit flow is for plugin bundle authors who know exactly which components they need and which frontend they target. The container subclass, component classes, and frontend are all fixed at write time:</p> <pre><code>from redsun.containers import device, presenter, view\nfrom redsun.qt import QtAppContainer\n\n# these are user-developed classes\n# that should reflect the structure\n# provided by sunflare for each layer\nfrom my_package.device import MyMotor\nfrom my_package.presenter import MyPresenter\nfrom my_package.view import MyView\n\n\nclass MyApp(QtAppContainer, config=\"config.yaml\"):\n    motor = device(MyMotor, from_config=\"motor\")\n    ctrl = presenter(MyPresenter, from_config=\"ctrl\")\n    ui = view(MyView, from_config=\"ui\")\n\nMyApp().run()\n</code></pre>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#dynamic-flow-configuration-driven","level":3,"title":"Dynamic flow (configuration-driven)","text":"<p>The dynamic flow is for end users who point Redsun at a YAML configuration file. Plugins are discovered via entry points and the frontend is resolved from the <code>frontend:</code> key in the file — no Python code needs to be written:</p> <pre><code>from redsun import AppContainer\n\napp = AppContainer.from_config(\"path/to/config.yaml\")\napp.run()\n</code></pre> <p>The YAML file drives everything:</p> <pre><code>schema_version: 1.0\nsession: \"My Experiment\"\nfrontend: \"pyqt\"\n\ndevices:\n  motor:\n    plugin_name: my-plugin\n    plugin_id: my_motor\n\npresenters:\n  ...\n\nviews:\n  ...\n</code></pre> <p>See the component system documentation for a full description of the dynamic flow.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#frontend-support","level":2,"title":"Frontend support","text":"<p>Frontend is intended as the toolkit that deploys the functionalities to implement the Graphical User Interface (GUI).</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#qt","level":3,"title":"Qt","text":"<p><code>QtAppContainer</code> extends <code>AppContainer</code> with the full Qt lifecycle:</p> <ol> <li>Creates the <code>QApplication</code> instance.</li> <li>Calls <code>build()</code> to instantiate all components.</li> <li>Constructs the <code>QtMainView</code> main window and docks all views.</li> <li>Starts the <code>psygnal</code> signal queue bridge for thread-safe signal delivery.</li> <li>Shows the main window and enters the Qt event loop.</li> </ol> <p>It is imported from the public <code>redsun.qt</code> namespace:</p> <pre><code>from redsun.qt import QtAppContainer\n</code></pre> <p>Both <code>PyQt6</code> or <code>PySide6</code> wrapped via <code>qtpy</code> are supported.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#other-frontends","level":3,"title":"Other frontends","text":"<p>The future expectation is to provide support for other frontends (either desktop or web-based).</p> <p>While the presenter and device layer are decoupled via the <code>VirtualContainer</code>, the <code>View</code> layer is tied to the frontend selection and plugins will have to implement each <code>View</code> according to the toolkit that the frontend provides. The hope is to find a way to minimize the code required to implement the UI and to simplify this approach across the board, regardless of the specified frontend.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/statement/","level":1,"title":"Statement of need","text":"<p>Scientific data acquisition often involves controlling a variety of hardware devices, coordinating measurements, and managing the resulting data and metadata. While the Bluesky ecosystem provides a powerful hardware abstraction layer and data model, building a complete application that integrates these capabilities into a usable interface remains a non-trivial task.</p> <p><code>redsun</code> aims to address this gap by providing a modular, event-driven framework for constructing scientific data acquisition applications.</p> <pre><code>graph TD\n    sunflare --&gt;|provides SDK for| components\n    sunflare --&gt;|provides SDK for| redsun\n    components --&gt;|loaded by| redsun\n    redsun --&gt;|assembles| application</code></pre>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#the-role-of-each-part","level":2,"title":"The role of each part","text":"<ul> <li>sunflare is the Software Development Kit (SDK) that provides shared base classes and communication patterns (devices, presenters, views, a shared container for inter-component communication and data exchange). It ensures a consistent programming model across the entire ecosystem.</li> <li>Components are user-developed packages that implement the actual hardware drivers, business logic, and UI components using <code>sunflare</code> abstractions.</li> <li>redsun is the application shell that discovers plugins, wires them together through its container architecture, and launches the final application.</li> </ul>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#design-philosophy","level":2,"title":"Design philosophy","text":"<p><code>redsun</code> follows three guiding principles:</p> <ol> <li>Don't reinvent the wheel - leverage existing tools like Bluesky's hardware protocols and Qt's UI framework. Instead of building everything from scratch, ship the tools to build the wheel.</li> <li>Be modular - users should be able to pick only the components they need. A plugin providing a motor controller should work independently of one providing a camera interface.</li> <li>Give users control - users own their data and metadata. The framework provides the structure but does not impose constraints on what data means or how it should be organized.</li> </ol>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#why-not-just-use-bluesky-directly","level":2,"title":"Why not just use Bluesky directly?","text":"<p>Bluesky was originally designed with an interactive approach in mind, in the sense that the user would directly control the <code>RunEngine</code> execution via a command-line interface or via <code>IPython</code>. This is imperative for the context in which Bluesky was developed (large experimental setups with multiple hardware devices connected to a central control system such as EPICS and Tango).</p> <p>What <code>redsun</code> provides on top of Bluesky is a more lab-bench experience, for setups that are meant to be controlled via a Graphical User Interface similar to Micro-Manager.</p>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/storage/","level":1,"title":"Storage","text":"<p>Redsun provides an optional, session-scoped storage layer that lets devices write acquired frames to disk without managing their own file handles or knowing where data lands. The design follows the same dependency injection principle as the rest of the container: devices declare intent, the container supplies the implementation.</p>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#overview","level":2,"title":"Overview","text":"<p>A single shared <code>Writer</code> instance is constructed once per session and injected into every device that opts in. All devices within a session write to the same store, each under its own array key, so data from multiple cameras or detectors ends up in one coherent file.</p> <pre><code>graph TD\n    YAML[YAML config storage section] --&gt;|_build_writer| W[Writer shared instance]\n    W --&gt;|injected via StorageDescriptor| D1[Device A storage = writer]\n    W --&gt;|injected via StorageDescriptor| D2[Device B storage = writer]\n    D3[Device C no StorageDescriptor] -. unaffected .-&gt; W</code></pre> <p>Storage is fully opt-in at two levels:</p> <ul> <li>Session level — no <code>storage:</code> section in the YAML means no writer is built and no injection occurs.</li> <li>Device level — only devices that declare <code>storage = StorageDescriptor()</code> in their class body receive the writer. Devices without the descriptor are unaffected.</li> </ul>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#opting-in-as-a-device-author","level":2,"title":"Opting in as a device author","text":"<p>Declare the descriptor as a class attribute:</p> <pre><code>from sunflare.storage import StorageDescriptor, StorageProxy\n\nclass MyDetector(Device):\n    storage = StorageDescriptor()\n</code></pre> <p><code>storage</code> starts as <code>None</code> and is set by the container at build time. Device code must guard against <code>None</code> before use:</p> <pre><code>def prepare(self, value: PrepareKwargs) -&gt; Status:\n    s = Status()\n    if self.storage is None:\n        s.set_exception(RuntimeError(\"No storage backend configured.\"))\n        return s\n    ...\n    self._sink = self.storage.prepare(self.name, capacity)\n    ...\n</code></pre> <p>The <code>StorageProxy</code> protocol is the full interface available on <code>self.storage</code> after injection — <code>update_source</code>, <code>prepare</code>, <code>kickoff</code>, <code>get_indices_written</code>, <code>collect_stream_docs</code>.</p>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#session-configuration","level":2,"title":"Session configuration","text":"<p>Add a <code>storage:</code> section to the session YAML. Only <code>backend</code> and <code>base_path</code> need to be specified for most use cases:</p> <pre><code>schema_version: 1.0\nsession: my-experiment\nfrontend: pyqt\n\nstorage:\n  backend: zarr\n  base_path: /data/scans        # C:/data/scans on Windows\n  filename_provider: auto_increment\n</code></pre> <p>All fields and their defaults:</p> Field Type Default Description <code>backend</code> <code>str</code> <code>\"zarr\"</code> Storage backend. Currently only <code>\"zarr\"</code> is supported. <code>base_path</code> <code>str</code> <code>~/redsun-storage/&lt;session&gt;</code> Base directory for all stores this session. Created automatically if absent. Plain filesystem path — no URI syntax needed. <code>filename_provider</code> <code>str</code> <code>\"auto_increment\"</code> Filename strategy (see below). <code>filename</code> <code>str</code> <code>\"scan\"</code> Static filename — only used when <code>filename_provider</code> is <code>\"static\"</code>.","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#filename-strategies","level":3,"title":"Filename strategies","text":"<p><code>filename_provider</code> controls how individual store names are generated within <code>base_path</code>:</p> auto_increment (default)uuidstatic <p>Stores are named <code>scan_00000</code>, <code>scan_00001</code>, … — predictable and human-readable. Never overwrites previous data.</p> <pre><code>storage:\n  backend: zarr\n  base_path: /data/scans\n  filename_provider: auto_increment\n</code></pre> <p>Produces: <code>/data/scans/scan_00000.zarr</code>, <code>/data/scans/scan_00001.zarr</code>, …</p> <p>Each store gets a random UUID4 name. Useful when concurrent writers must avoid any chance of collision.</p> <pre><code>storage:\n  backend: zarr\n  base_path: /data/scans\n  filename_provider: uuid\n</code></pre> <p>Produces: <code>/data/scans/3f2504e0-4f89-11d3-9a0c-0305e82c3301.zarr</code>, …</p> <p>Every acquisition writes to the same filename. Use only when you explicitly want to overwrite.</p> <pre><code>storage:\n  backend: zarr\n  base_path: /data/scans\n  filename_provider: static\n  filename: background\n</code></pre> <p>Produces: <code>/data/scans/background.zarr</code> (overwritten each run).</p>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#default-store-location","level":3,"title":"Default store location","text":"<p>When <code>base_path</code> is omitted, Redsun creates stores under <code>~/redsun-storage/&lt;session&gt;</code>:</p> <pre><code>session: my-experiment\nstorage:\n  backend: zarr\n  # → ~/redsun-storage/my-experiment/scan_00000.zarr\n</code></pre> <p>The directory is created automatically on first use.</p>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#how-injection-works","level":2,"title":"How injection works","text":"<p>During <code>build()</code>, after all devices are constructed, the container checks each device for a <code>StorageDescriptor</code> anywhere in its class hierarchy (full MRO walk). Devices that have one receive the shared writer via <code>setattr</code>. The check is performed by the private <code>_HasStorage</code> protocol, whose metaclass overrides <code>__instancecheck__</code> to inspect the class rather than the instance value — this correctly identifies opted-in devices even when <code>storage</code> is currently <code>None</code>.</p> <p>Future: per-plan override</p> <p>The filename provider is currently fixed for the lifetime of the session. A future release will expose a way to swap strategies at plan time — for example to use a static name for background acquisitions and auto-increment for experimental runs.</p>","path":["Explanation","Storage"],"tags":[]},{"location":"explanation/storage/#backend-dependencies","level":2,"title":"Backend dependencies","text":"<p>The <code>zarr</code> backend requires the optional <code>acquire-zarr</code> package, installed via:</p> <pre><code>pip install sunflare[zarr]\n</code></pre> <p>The import is deferred until the writer is actually built, so sessions without a <code>storage:</code> section have no dependency on <code>acquire-zarr</code>.</p> <p>Future backends (<code>hdf5</code>, <code>ome-zarr</code>, <code>tiff</code>) will follow the same optional-extra pattern.</p>","path":["Explanation","Storage"],"tags":[]},{"location":"how-to/","level":1,"title":"How-to guides","text":"","path":["How-to guides"],"tags":[]},{"location":"how-to/#getting-started","level":2,"title":"Getting started","text":"<ul> <li>Installation</li> <li>Build documentation</li> <li>Run tests</li> </ul>","path":["How-to guides"],"tags":[]},{"location":"how-to/build-docs/","level":1,"title":"Build documentation","text":"<p>This guide covers how to build the Redsun documentation locally.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed <code>redsun</code> with development dependencies.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#build-with-zensical","level":2,"title":"Build with Zensical","text":"<p>Build the documentation from the project root:</p> <pre><code>uv run zensical build\n</code></pre> <p>The built documentation will be in the <code>site/</code> directory. You can serve the documentation locally via:</p> <pre><code>uv run zensical serve\n</code></pre> <p>This starts a local server at <code>http://localhost:8000</code> and automatically rebuilds when you make changes.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#missing-dependencies","level":3,"title":"Missing dependencies","text":"<p>If you get errors about missing dependencies:</p> <pre><code>uv sync\n</code></pre>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#port-already-in-use","level":3,"title":"Port already in use","text":"<p>If port 8000 is already in use, specify a different port:</p> <pre><code>uv run zensical serve --dev-addr localhost:8080\n</code></pre>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Learn how to run tests</li> <li>Read about Redsun's architecture</li> </ul>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/installation/","level":1,"title":"Installation","text":"<p>This guide covers how to install <code>redsun</code> in different environments.</p>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#create-a-virtual-environment","level":2,"title":"Create a virtual environment","text":"<p>It is recommended to install the package in a virtual environment.</p> uv (recommended)venvcondamamba <pre><code>uv venv --python 3.10\n\n# For Linux/macOS\nsource .venv/bin/activate\n\n# For Windows Command Prompt\n.venv\\Scripts\\activate.bat\n\n# For Windows PowerShell\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code># Python version depends on the globally installed Python\npython -m venv redsun-env\n\n# For Linux/macOS\nsource redsun-env/bin/activate\n\n# For Windows Command Prompt\nredsun-env\\Scripts\\activate.bat\n\n# For Windows PowerShell\nredsun-env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>conda create -n redsun-env python=3.10\nconda activate redsun-env\n</code></pre> <pre><code>mamba create -n redsun-env python=3.10\nmamba activate redsun-env\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#install-redsun","level":2,"title":"Install Redsun","text":"<p>The package is available on PyPI or directly from the GitHub repository.</p> PyPIGitHub (development) <pre><code>pip install -U redsun\n\n# Or if you're using uv\nuv pip install redsun\n</code></pre> <pre><code>git clone https://github.com/redsun-acquisition/redsun.git\ncd redsun\npip install -e .\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#qt-backend","level":3,"title":"Qt backend","text":"<p><code>redsun</code> requires a Qt backend. Install with your preferred binding:</p> PyQt6PySide6 <pre><code>pip install redsun[pyqt]\n</code></pre> <pre><code>pip install redsun[pyside]\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#install-development-dependencies","level":2,"title":"Install development dependencies","text":"<p>If you are contributing to <code>redsun</code> or want to run tests locally, install the development dependencies via PEP-735 dependency groups.</p> uv (recommended)pip <pre><code>uv sync\n</code></pre> <pre><code>pip install -e .[dev]\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/run-tests/","level":1,"title":"Run tests","text":"<p>This guide covers how to run the <code>redsun</code> test suite and generate coverage reports.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed <code>redsun</code> with development dependencies.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-all-tests","level":2,"title":"Run all tests","text":"<p>Run the tests from the project root:</p> <pre><code>pytest\n</code></pre>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#generate-coverage-report","level":2,"title":"Generate coverage report","text":"<p>Obtain a test coverage report:</p> <pre><code>pytest --cov=redsun --cov-report=html\n</code></pre> <p>This generates an <code>htmlcov/</code> directory. Open <code>htmlcov/index.html</code> in your browser to view it.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-specific-tests","level":2,"title":"Run specific tests","text":"<pre><code># Run a specific test file\npytest tests/test_config.py\n\n# Run a specific test function\npytest tests/test_config.py::test_function_name\n\n# Run tests matching a pattern\npytest -k \"test_container\"\n</code></pre>","path":["How-to guides","Run tests"],"tags":[]},{"location":"reference/","level":1,"title":"Reference","text":"<ul> <li>API reference - Public API</li> <li>Changelog - Version history and release notes</li> </ul>","path":["Reference"],"tags":[]},{"location":"reference/api/","level":1,"title":"API reference","text":"","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components","level":2,"title":"<code>components</code>","text":"","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components.device","level":3,"title":"<code>device(cls, /, alias=None, from_config=None, **kwargs)</code>","text":"<p>Declare a component as a device layer field.</p> <p>A device can be declared inside the body of an <code>AppContainer</code>:</p> <pre><code>class MyApp(AppContainer):\n    motor = device(MyMotor, axis=[\"X\"])\n</code></pre> <p>The container will create an instance of <code>MyMotor</code> with the specified kwargs when the container is built. The attribute name <code>motor</code> will be used as the device <code>name</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to instantiate.</p> required <code>alias</code> <code>str | None</code> <p>Override the component name. Takes priority over the attribute name.</p> <code>None</code> <code>from_config</code> <code>str | None</code> <p>Key to look up in the configuration file's <code>devices</code> section.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments forwarded to the component constructor.</p> <code>{}</code> Source code in <code>src/redsun/containers/components.py</code> <pre><code>def device(\n    cls: type,\n    /,\n    alias: str | None = None,\n    from_config: str | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Declare a component as a device layer field.\n\n    A device can be declared inside the body of an `AppContainer`:\n\n    ```python\n    class MyApp(AppContainer):\n        motor = device(MyMotor, axis=[\"X\"])\n    ```\n\n    The container will create an instance of `MyMotor` with the specified kwargs when the\n    container is built. The attribute name ``motor`` will be used as the device ``name`` argument.\n\n    Parameters\n    ----------\n    cls : type\n        The component class to instantiate.\n    alias : str | None\n        Override the component name. Takes priority over the attribute name.\n    from_config : str | None\n        Key to look up in the configuration file's ``devices`` section.\n    **kwargs : Any\n        Additional keyword arguments forwarded to the component constructor.\n    \"\"\"\n    return _DeviceField(cls=cls, alias=alias, from_config=from_config, kwargs=kwargs)\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components.presenter","level":3,"title":"<code>presenter(cls, /, alias=None, from_config=None, **kwargs)</code>","text":"<p>Declare a component as a presenter layer field.</p> <pre><code>class MyApp(AppContainer):\n    ctrl = presenter(MyCtrl, gain=1.0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to instantiate.</p> required <code>alias</code> <code>str | None</code> <p>Override the component name. Takes priority over the attribute name.</p> <code>None</code> <code>from_config</code> <code>str | None</code> <p>Key to look up in the configuration file's <code>presenters</code> section.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments forwarded to the component constructor.</p> <code>{}</code> Source code in <code>src/redsun/containers/components.py</code> <pre><code>def presenter(\n    cls: type,\n    /,\n    alias: str | None = None,\n    from_config: str | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Declare a component as a presenter layer field.\n\n    ```python\n    class MyApp(AppContainer):\n        ctrl = presenter(MyCtrl, gain=1.0)\n    ```\n\n    Parameters\n    ----------\n    cls : type\n        The component class to instantiate.\n    alias : str | None\n        Override the component name. Takes priority over the attribute name.\n    from_config : str | None\n        Key to look up in the configuration file's ``presenters`` section.\n    **kwargs : Any\n        Additional keyword arguments forwarded to the component constructor.\n    \"\"\"\n    return _PresenterField(cls=cls, alias=alias, from_config=from_config, kwargs=kwargs)\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components.view","level":3,"title":"<code>view(cls, /, alias=None, from_config=None, **kwargs)</code>","text":"<p>Declare a component as a view layer field.</p> <pre><code>class MyApp(AppContainer):\n    ui = view(MyView)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to instantiate.</p> required <code>alias</code> <code>str | None</code> <p>Override the component name. Takes priority over the attribute name.</p> <code>None</code> <code>from_config</code> <code>str | None</code> <p>Key to look up in the configuration file's <code>views</code> section.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments forwarded to the component constructor.</p> <code>{}</code> Source code in <code>src/redsun/containers/components.py</code> <pre><code>def view(\n    cls: type,\n    /,\n    alias: str | None = None,\n    from_config: str | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Declare a component as a view layer field.\n\n    ```python\n    class MyApp(AppContainer):\n        ui = view(MyView)\n    ```\n\n    Parameters\n    ----------\n    cls : type\n        The component class to instantiate.\n    alias : str | None\n        Override the component name. Takes priority over the attribute name.\n    from_config : str | None\n        Key to look up in the configuration file's ``views`` section.\n    **kwargs : Any\n        Additional keyword arguments forwarded to the component constructor.\n    \"\"\"\n    return _ViewField(cls=cls, alias=alias, from_config=from_config, kwargs=kwargs)\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainerMeta","level":2,"title":"<code>AppContainerMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass that auto-collects component wrappers from class attributes.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>class AppContainerMeta(type):\n    \"\"\"Metaclass that auto-collects component wrappers from class attributes.\"\"\"\n\n    _device_components: dict[str, _DeviceComponent]\n    _presenter_components: dict[str, _PresenterComponent]\n    _view_components: dict[str, _ViewComponent]\n    _config_path: Path | None\n\n    def __new__(\n        mcs,\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        config: str | Path | None = None,\n        **kwargs: Any,\n    ) -&gt; AppContainerMeta:\n        \"\"\"Create the class and collect component wrappers.\n\n        Parameters\n        ----------\n        config : str | Path | None\n            Path to a YAML configuration file for component kwargs.\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace, **kwargs)\n\n        config_path: Path | None = None\n        if config is not None:\n            config_path = Path(config)\n        else:\n            for base in bases:\n                if hasattr(base, \"_config_path\") and base._config_path is not None:\n                    if isinstance(base._config_path, str):\n                        config_path = Path(base._config_path)\n                    elif isinstance(base._config_path, Path):\n                        config_path = base._config_path\n                    config_path = base._config_path\n                    break\n        cls._config_path = config_path\n\n        devices: dict[str, _DeviceComponent] = {}\n        presenters: dict[str, _PresenterComponent] = {}\n        views: dict[str, _ViewComponent] = {}\n\n        for base in bases:\n            if hasattr(base, \"_device_components\"):\n                devices.update(base._device_components)\n            if hasattr(base, \"_presenter_components\"):\n                presenters.update(base._presenter_components)\n            if hasattr(base, \"_view_components\"):\n                views.update(base._view_components)\n\n        for attr_name, attr_value in namespace.items():\n            if attr_name.startswith(\"_\"):\n                continue\n\n            if isinstance(attr_value, _DeviceComponent):\n                devices[attr_value.name] = attr_value\n            elif isinstance(attr_value, _PresenterComponent):\n                presenters[attr_value.name] = attr_value\n            elif isinstance(attr_value, _ViewComponent):\n                views[attr_value.name] = attr_value\n\n        component_fields = {\n            attr_name: value\n            for attr_name, value in namespace.items()\n            if not attr_name.startswith(\"_\") and isinstance(value, _AnyField)\n        }\n\n        if component_fields:\n            config_data: dict[str, Any] = {}\n            if config_path is not None:\n                config_data = _load_yaml(config_path)\n\n            _section_key: dict[type, str] = {\n                _DeviceField: \"devices\",\n                _PresenterField: \"presenters\",\n                _ViewField: \"views\",\n            }\n\n            for attr_name, field in component_fields.items():\n                kw = field.kwargs\n                if field.from_config is not None:\n                    if not config_data:\n                        raise TypeError(\n                            f\"Component field '{attr_name}' in {name} has \"\n                            f\"from_config set but no config path was \"\n                            f\"provided to the container class\"\n                        )\n\n                    section_key = _section_key[type(field)]\n                    section_data: dict[str, Any] = config_data.get(section_key, {})\n                    _sentinel = object()\n                    cfg_section = section_data.get(field.from_config, _sentinel)\n\n                    if cfg_section is _sentinel:\n                        logger.warning(\n                            f\"No config section '{field.from_config}' found in \"\n                            f\"'{section_key}' for component field '{attr_name}' in {name}, \"\n                            f\"using inline kwargs only\"\n                        )\n                        kw = field.kwargs\n                    else:\n                        kw = {**(cfg_section or {}), **field.kwargs}\n\n                comp_name = field.alias if field.alias is not None else attr_name\n\n                wrapper: _DeviceComponent | _PresenterComponent | _ViewComponent\n                if isinstance(field, _DeviceField):\n                    wrapper = _DeviceComponent(field.cls, comp_name, **kw)\n                    devices[comp_name] = wrapper\n                elif isinstance(field, _PresenterField):\n                    wrapper = _PresenterComponent(field.cls, comp_name, **kw)\n                    presenters[comp_name] = wrapper\n                else:\n                    wrapper = _ViewComponent(field.cls, comp_name, **kw)\n                    views[comp_name] = wrapper\n                setattr(cls, attr_name, wrapper)\n\n        cls._device_components = devices\n        cls._presenter_components = presenters\n        cls._view_components = views\n\n        if devices or presenters or views:\n            logger.debug(\n                f\"Collected from {name}: \"\n                f\"{len(devices)} devices, \"\n                f\"{len(presenters)} presenters, \"\n                f\"{len(views)} views\"\n            )\n\n        return cls\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainerMeta.__new__","level":3,"title":"<code>__new__(mcs, name, bases, namespace, config=None, **kwargs)</code>","text":"<p>Create the class and collect component wrappers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str | Path | None</code> <p>Path to a YAML configuration file for component kwargs.</p> <code>None</code> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def __new__(\n    mcs,\n    name: str,\n    bases: tuple[type, ...],\n    namespace: dict[str, Any],\n    config: str | Path | None = None,\n    **kwargs: Any,\n) -&gt; AppContainerMeta:\n    \"\"\"Create the class and collect component wrappers.\n\n    Parameters\n    ----------\n    config : str | Path | None\n        Path to a YAML configuration file for component kwargs.\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace, **kwargs)\n\n    config_path: Path | None = None\n    if config is not None:\n        config_path = Path(config)\n    else:\n        for base in bases:\n            if hasattr(base, \"_config_path\") and base._config_path is not None:\n                if isinstance(base._config_path, str):\n                    config_path = Path(base._config_path)\n                elif isinstance(base._config_path, Path):\n                    config_path = base._config_path\n                config_path = base._config_path\n                break\n    cls._config_path = config_path\n\n    devices: dict[str, _DeviceComponent] = {}\n    presenters: dict[str, _PresenterComponent] = {}\n    views: dict[str, _ViewComponent] = {}\n\n    for base in bases:\n        if hasattr(base, \"_device_components\"):\n            devices.update(base._device_components)\n        if hasattr(base, \"_presenter_components\"):\n            presenters.update(base._presenter_components)\n        if hasattr(base, \"_view_components\"):\n            views.update(base._view_components)\n\n    for attr_name, attr_value in namespace.items():\n        if attr_name.startswith(\"_\"):\n            continue\n\n        if isinstance(attr_value, _DeviceComponent):\n            devices[attr_value.name] = attr_value\n        elif isinstance(attr_value, _PresenterComponent):\n            presenters[attr_value.name] = attr_value\n        elif isinstance(attr_value, _ViewComponent):\n            views[attr_value.name] = attr_value\n\n    component_fields = {\n        attr_name: value\n        for attr_name, value in namespace.items()\n        if not attr_name.startswith(\"_\") and isinstance(value, _AnyField)\n    }\n\n    if component_fields:\n        config_data: dict[str, Any] = {}\n        if config_path is not None:\n            config_data = _load_yaml(config_path)\n\n        _section_key: dict[type, str] = {\n            _DeviceField: \"devices\",\n            _PresenterField: \"presenters\",\n            _ViewField: \"views\",\n        }\n\n        for attr_name, field in component_fields.items():\n            kw = field.kwargs\n            if field.from_config is not None:\n                if not config_data:\n                    raise TypeError(\n                        f\"Component field '{attr_name}' in {name} has \"\n                        f\"from_config set but no config path was \"\n                        f\"provided to the container class\"\n                    )\n\n                section_key = _section_key[type(field)]\n                section_data: dict[str, Any] = config_data.get(section_key, {})\n                _sentinel = object()\n                cfg_section = section_data.get(field.from_config, _sentinel)\n\n                if cfg_section is _sentinel:\n                    logger.warning(\n                        f\"No config section '{field.from_config}' found in \"\n                        f\"'{section_key}' for component field '{attr_name}' in {name}, \"\n                        f\"using inline kwargs only\"\n                    )\n                    kw = field.kwargs\n                else:\n                    kw = {**(cfg_section or {}), **field.kwargs}\n\n            comp_name = field.alias if field.alias is not None else attr_name\n\n            wrapper: _DeviceComponent | _PresenterComponent | _ViewComponent\n            if isinstance(field, _DeviceField):\n                wrapper = _DeviceComponent(field.cls, comp_name, **kw)\n                devices[comp_name] = wrapper\n            elif isinstance(field, _PresenterField):\n                wrapper = _PresenterComponent(field.cls, comp_name, **kw)\n                presenters[comp_name] = wrapper\n            else:\n                wrapper = _ViewComponent(field.cls, comp_name, **kw)\n                views[comp_name] = wrapper\n            setattr(cls, attr_name, wrapper)\n\n    cls._device_components = devices\n    cls._presenter_components = presenters\n    cls._view_components = views\n\n    if devices or presenters or views:\n        logger.debug(\n            f\"Collected from {name}: \"\n            f\"{len(devices)} devices, \"\n            f\"{len(presenters)} presenters, \"\n            f\"{len(views)} views\"\n        )\n\n    return cls\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer","level":2,"title":"<code>AppContainer</code>","text":"<p>Application container for MVP architecture.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>class AppContainer(metaclass=AppContainerMeta):\n    \"\"\"Application container for MVP architecture.\"\"\"\n\n    _device_components: ClassVar[dict[str, _DeviceComponent]]\n    _presenter_components: ClassVar[dict[str, _PresenterComponent]]\n    _view_components: ClassVar[dict[str, _ViewComponent]]\n\n    __slots__ = (\n        \"_config\",\n        \"_virtual_container\",\n        \"_is_built\",\n    )\n\n    def __init__(self, *, session: str = \"Redsun\", frontend: str = \"pyqt\") -&gt; None:\n        self._config: AppConfig = {\n            \"schema_version\": 1.0,\n            \"session\": session,\n            \"frontend\": frontend,\n        }\n        self._virtual_container: VirtualContainer | None = None\n        self._is_built: bool = False\n\n    @property\n    def config(self) -&gt; AppConfig:\n        \"\"\"Return the application configuration.\"\"\"\n        return self._config\n\n    @property\n    def devices(self) -&gt; dict[str, Device]:\n        \"\"\"Return built device instances.\"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {name: comp.instance for name, comp in self._device_components.items()}\n\n    @property\n    def presenters(self) -&gt; dict[str, Presenter]:\n        \"\"\"Return built presenter instances.\"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {\n            name: comp.instance for name, comp in self._presenter_components.items()\n        }\n\n    @property\n    def views(self) -&gt; dict[str, View]:\n        \"\"\"Return built view instances.\"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {name: comp.instance for name, comp in self._view_components.items()}\n\n    @property\n    def virtual_container(self) -&gt; VirtualContainer:\n        \"\"\"Return the virtual container instance.\"\"\"\n        if self._virtual_container is None:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return self._virtual_container\n\n    @property\n    def is_built(self) -&gt; bool:\n        \"\"\"Return whether the container has been built.\"\"\"\n        return self._is_built\n\n    def build(self) -&gt; Self:\n        \"\"\"Instantiate all components in dependency order.\n\n        Build order:\n\n        1. VirtualContainer\n        2. Devices\n        3. Presenters (register their providers in the VirtualContainer)\n        4. Views (inject dependencies from the VirtualContainer)\n        \"\"\"\n        if self._is_built:\n            logger.warning(\"Container already built, skipping rebuild\")\n            return self\n\n        logger.info(\"Building application container...\")\n\n        self._virtual_container = VirtualContainer()\n\n        base_cfg: RedSunConfig = {\n            \"schema_version\": self._config.get(\"schema_version\", 1.0),\n            \"session\": self._config.get(\"session\", \"Redsun\"),\n            \"frontend\": self._config.get(\"frontend\", \"pyqt\"),\n        }\n        self._virtual_container._set_configuration(base_cfg)\n        logger.debug(\"VirtualContainer created\")\n\n        # build devices\n        built_devices: dict[str, Device] = {}\n        for name, device_comp in self._device_components.items():\n            try:\n                built_devices[name] = device_comp.build()\n                logger.debug(f\"Device '{name}' built\")\n            except Exception as e:\n                logger.error(f\"Failed to build device '{name}': {e}\")\n\n        # inject storage writer if configured\n        storage_cfg = self._config.get(\"storage\")\n        if storage_cfg is not None:\n            try:\n                writer = _build_writer(\n                    storage_cfg, self._config.get(\"session\", \"redsun\")\n                )\n                _inject_storage(built_devices, writer)\n                logger.debug(\"Storage writer built and injected\")\n            except Exception as e:\n                logger.error(f\"Failed to build storage writer: {e}\")\n\n        # build presenters\n        for comp_name, presenter_component in self._presenter_components.items():\n            try:\n                presenter_component.build(built_devices)\n            except Exception as e:\n                logger.error(f\"Failed to build presenter '{comp_name}': {e}\")\n                raise\n\n        # build views\n        for comp_name, view_component in self._view_components.items():\n            try:\n                view_component.build()\n            except Exception as e:\n                logger.error(f\"Failed to build view '{comp_name}': {e}\")\n                raise\n\n        # register providers from presenters and views\n        all_components: dict[str, _PresenterComponent | _ViewComponent] = {\n            **self._presenter_components,\n            **self._view_components,\n        }\n        for comp_name, component in all_components.items():\n            if isinstance(component.instance, IsProvider):\n                component.instance.register_providers(self._virtual_container)\n\n        # inject dependencies into presenters and views\n        for comp_name, component in all_components.items():\n            if isinstance(component.instance, IsInjectable):\n                component.instance.inject_dependencies(self._virtual_container)\n\n        self._is_built = True\n        logger.info(\n            f\"Container built: \"\n            f\"{len(self._device_components)} devices, \"\n            f\"{len(self._presenter_components)} presenters, \"\n            f\"{len(self._view_components)} views\"\n        )\n\n        return self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown all presenters that implement ``HasShutdown``.\"\"\"\n        if not self._is_built:\n            return\n\n        for name, comp in self._presenter_components.items():\n            if isinstance(comp.instance, HasShutdown):\n                try:\n                    comp.instance.shutdown()\n                except Exception as e:\n                    logger.error(f\"Error shutting down presenter '{name}': {e}\")\n\n        self._is_built = False\n        logger.info(\"Container shutdown complete\")\n\n    def run(self) -&gt; None:\n        \"\"\"Build if needed and start the application.\"\"\"\n        if not self._is_built:\n            self.build()\n\n        frontend = self._config.get(\"frontend\", \"pyqt\")\n        logger.info(f\"Starting application with frontend: {frontend}\")\n\n    @classmethod\n    def from_config(cls, config_path: str) -&gt; AppContainer:\n        \"\"\"Build a container dynamically from a YAML configuration file.\"\"\"\n        config, plugin_types = cls._load_configuration(config_path)\n\n        namespace: dict[str, Any] = {}\n\n        for name, device_class in plugin_types[\"devices\"].items():\n            cfg_kwargs = {\n                k: v\n                for k, v in config.get(\"devices\", {}).get(name, {}).items()\n                if k not in _PLUGIN_META_KEYS\n            }\n            namespace[name] = _DeviceComponent(device_class, name, **cfg_kwargs)\n\n        for name, presenter_class in plugin_types[\"presenters\"].items():\n            cfg_kwargs = {\n                k: v\n                for k, v in config.get(\"presenters\", {}).get(name, {}).items()\n                if k not in _PLUGIN_META_KEYS\n            }\n            namespace[name] = _PresenterComponent(presenter_class, name, **cfg_kwargs)\n\n        for name, view_class in plugin_types[\"views\"].items():\n            cfg_kwargs = {\n                k: v\n                for k, v in config.get(\"views\", {}).get(name, {}).items()\n                if k not in _PLUGIN_META_KEYS\n            }\n            namespace[name] = _ViewComponent(view_class, name, **cfg_kwargs)\n\n        frontend = config.get(\"frontend\", \"pyqt\")\n        base_class = _resolve_frontend_container(frontend)\n\n        DynamicApp: type[AppContainer] = type(\"DynamicApp\", (base_class,), namespace)\n\n        instance = DynamicApp(\n            session=config.get(\"session\", \"Redsun\"),\n            frontend=frontend,\n        )\n\n        storage_cfg = config.get(\"storage\")\n        if storage_cfg is not None:\n            instance._config[\"storage\"] = storage_cfg\n\n        return instance\n\n    @classmethod\n    def _load_configuration(\n        cls, config_path: str\n    ) -&gt; tuple[dict[str, Any], _PluginTypeDict]:\n        \"\"\"Load configuration and discover plugin classes from a YAML file.\"\"\"\n        with open(config_path, \"r\") as f:\n            config: dict[str, Any] = yaml.safe_load(f)\n\n        plugin_types: _PluginTypeDict = {\"devices\": {}, \"presenters\": {}, \"views\": {}}\n        available_manifests = entry_points(group=\"redsun.plugins\")\n\n        groups: list[PLUGIN_GROUPS] = [\"devices\", \"presenters\", \"views\"]\n\n        for group in groups:\n            if group not in config:\n                logger.debug(\n                    \"Group %s not found in the configuration file. Skipping\", group\n                )\n                continue\n            loaded = cls._load_plugins(\n                group_cfg=config[group],\n                group=group,\n                available_manifests=available_manifests,\n            )\n            for name, plugin_cls in loaded:\n                plugin_types[group][name] = plugin_cls  # type: ignore[assignment]\n\n        return config, plugin_types\n\n    @classmethod\n    def _load_plugins(\n        cls,\n        *,\n        group_cfg: dict[str, Any],\n        group: PLUGIN_GROUPS,\n        available_manifests: EntryPoints,\n    ) -&gt; list[tuple[str, PluginType]]:\n        \"\"\"Load plugin classes for a given group from manifests.\"\"\"\n        plugins: list[tuple[str, PluginType]] = []\n\n        for name, info in group_cfg.items():\n            plugin_name: str = info[\"plugin_name\"]\n            plugin_id: str = info[\"plugin_id\"]\n\n            iterator = (\n                entry for entry in available_manifests if entry.name == plugin_name\n            )\n            plugin = next(iterator, None)\n\n            if plugin is None:\n                logger.error(\n                    'Plugin \"%s\" not found in the installed plugins.', plugin_name\n                )\n                continue\n\n            pkg_manifest = files(plugin.name.replace(\"-\", \"_\")) / plugin.value\n            with as_file(pkg_manifest) as manifest_path:\n                with open(manifest_path, \"r\") as f:\n                    manifest: dict[str, ManifestItems] = yaml.safe_load(f)\n\n                if group not in manifest:\n                    logger.error(\n                        'Plugin \"%s\" manifest does not contain group \"%s\".',\n                        plugin_name,\n                        group,\n                    )\n                    continue\n\n                items = manifest[group]\n                if plugin_id not in items:\n                    logger.error(\n                        'Plugin \"%s\" does not contain the id \"%s\".',\n                        plugin_name,\n                        plugin_id,\n                    )\n                    continue\n\n                class_path = items[plugin_id]\n                try:\n                    class_item_module, class_item_type = class_path.split(\":\")\n                    imported_class = getattr(\n                        import_module(class_item_module), class_item_type\n                    )\n                except (KeyError, ValueError):\n                    logger.error(\n                        'Plugin id \"%s\" of \"%s\" has invalid class path \"%s\". Skipping.',\n                        plugin_id,\n                        name,\n                        class_path,\n                    )\n                    continue\n\n                if not _check_plugin_protocol(imported_class, group):\n                    logger.error(\n                        \"%s exists, but does not implement any known protocol.\",\n                        imported_class,\n                    )\n                    continue\n\n                plugins.append((name, imported_class))\n\n        return plugins\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.config","level":3,"title":"<code>config</code>  <code>property</code>","text":"<p>Return the application configuration.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.devices","level":3,"title":"<code>devices</code>  <code>property</code>","text":"<p>Return built device instances.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.presenters","level":3,"title":"<code>presenters</code>  <code>property</code>","text":"<p>Return built presenter instances.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.views","level":3,"title":"<code>views</code>  <code>property</code>","text":"<p>Return built view instances.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.virtual_container","level":3,"title":"<code>virtual_container</code>  <code>property</code>","text":"<p>Return the virtual container instance.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.is_built","level":3,"title":"<code>is_built</code>  <code>property</code>","text":"<p>Return whether the container has been built.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.build","level":3,"title":"<code>build()</code>","text":"<p>Instantiate all components in dependency order.</p> <p>Build order:</p> <ol> <li>VirtualContainer</li> <li>Devices</li> <li>Presenters (register their providers in the VirtualContainer)</li> <li>Views (inject dependencies from the VirtualContainer)</li> </ol> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def build(self) -&gt; Self:\n    \"\"\"Instantiate all components in dependency order.\n\n    Build order:\n\n    1. VirtualContainer\n    2. Devices\n    3. Presenters (register their providers in the VirtualContainer)\n    4. Views (inject dependencies from the VirtualContainer)\n    \"\"\"\n    if self._is_built:\n        logger.warning(\"Container already built, skipping rebuild\")\n        return self\n\n    logger.info(\"Building application container...\")\n\n    self._virtual_container = VirtualContainer()\n\n    base_cfg: RedSunConfig = {\n        \"schema_version\": self._config.get(\"schema_version\", 1.0),\n        \"session\": self._config.get(\"session\", \"Redsun\"),\n        \"frontend\": self._config.get(\"frontend\", \"pyqt\"),\n    }\n    self._virtual_container._set_configuration(base_cfg)\n    logger.debug(\"VirtualContainer created\")\n\n    # build devices\n    built_devices: dict[str, Device] = {}\n    for name, device_comp in self._device_components.items():\n        try:\n            built_devices[name] = device_comp.build()\n            logger.debug(f\"Device '{name}' built\")\n        except Exception as e:\n            logger.error(f\"Failed to build device '{name}': {e}\")\n\n    # inject storage writer if configured\n    storage_cfg = self._config.get(\"storage\")\n    if storage_cfg is not None:\n        try:\n            writer = _build_writer(\n                storage_cfg, self._config.get(\"session\", \"redsun\")\n            )\n            _inject_storage(built_devices, writer)\n            logger.debug(\"Storage writer built and injected\")\n        except Exception as e:\n            logger.error(f\"Failed to build storage writer: {e}\")\n\n    # build presenters\n    for comp_name, presenter_component in self._presenter_components.items():\n        try:\n            presenter_component.build(built_devices)\n        except Exception as e:\n            logger.error(f\"Failed to build presenter '{comp_name}': {e}\")\n            raise\n\n    # build views\n    for comp_name, view_component in self._view_components.items():\n        try:\n            view_component.build()\n        except Exception as e:\n            logger.error(f\"Failed to build view '{comp_name}': {e}\")\n            raise\n\n    # register providers from presenters and views\n    all_components: dict[str, _PresenterComponent | _ViewComponent] = {\n        **self._presenter_components,\n        **self._view_components,\n    }\n    for comp_name, component in all_components.items():\n        if isinstance(component.instance, IsProvider):\n            component.instance.register_providers(self._virtual_container)\n\n    # inject dependencies into presenters and views\n    for comp_name, component in all_components.items():\n        if isinstance(component.instance, IsInjectable):\n            component.instance.inject_dependencies(self._virtual_container)\n\n    self._is_built = True\n    logger.info(\n        f\"Container built: \"\n        f\"{len(self._device_components)} devices, \"\n        f\"{len(self._presenter_components)} presenters, \"\n        f\"{len(self._view_components)} views\"\n    )\n\n    return self\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.shutdown","level":3,"title":"<code>shutdown()</code>","text":"<p>Shutdown all presenters that implement <code>HasShutdown</code>.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown all presenters that implement ``HasShutdown``.\"\"\"\n    if not self._is_built:\n        return\n\n    for name, comp in self._presenter_components.items():\n        if isinstance(comp.instance, HasShutdown):\n            try:\n                comp.instance.shutdown()\n            except Exception as e:\n                logger.error(f\"Error shutting down presenter '{name}': {e}\")\n\n    self._is_built = False\n    logger.info(\"Container shutdown complete\")\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.run","level":3,"title":"<code>run()</code>","text":"<p>Build if needed and start the application.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Build if needed and start the application.\"\"\"\n    if not self._is_built:\n        self.build()\n\n    frontend = self._config.get(\"frontend\", \"pyqt\")\n    logger.info(f\"Starting application with frontend: {frontend}\")\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.from_config","level":3,"title":"<code>from_config(config_path)</code>  <code>classmethod</code>","text":"<p>Build a container dynamically from a YAML configuration file.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>@classmethod\ndef from_config(cls, config_path: str) -&gt; AppContainer:\n    \"\"\"Build a container dynamically from a YAML configuration file.\"\"\"\n    config, plugin_types = cls._load_configuration(config_path)\n\n    namespace: dict[str, Any] = {}\n\n    for name, device_class in plugin_types[\"devices\"].items():\n        cfg_kwargs = {\n            k: v\n            for k, v in config.get(\"devices\", {}).get(name, {}).items()\n            if k not in _PLUGIN_META_KEYS\n        }\n        namespace[name] = _DeviceComponent(device_class, name, **cfg_kwargs)\n\n    for name, presenter_class in plugin_types[\"presenters\"].items():\n        cfg_kwargs = {\n            k: v\n            for k, v in config.get(\"presenters\", {}).get(name, {}).items()\n            if k not in _PLUGIN_META_KEYS\n        }\n        namespace[name] = _PresenterComponent(presenter_class, name, **cfg_kwargs)\n\n    for name, view_class in plugin_types[\"views\"].items():\n        cfg_kwargs = {\n            k: v\n            for k, v in config.get(\"views\", {}).get(name, {}).items()\n            if k not in _PLUGIN_META_KEYS\n        }\n        namespace[name] = _ViewComponent(view_class, name, **cfg_kwargs)\n\n    frontend = config.get(\"frontend\", \"pyqt\")\n    base_class = _resolve_frontend_container(frontend)\n\n    DynamicApp: type[AppContainer] = type(\"DynamicApp\", (base_class,), namespace)\n\n    instance = DynamicApp(\n        session=config.get(\"session\", \"Redsun\"),\n        frontend=frontend,\n    )\n\n    storage_cfg = config.get(\"storage\")\n    if storage_cfg is not None:\n        instance._config[\"storage\"] = storage_cfg\n\n    return instance\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.AppConfig","level":2,"title":"<code>AppConfig</code>","text":"<p>               Bases: <code>RedSunConfig</code></p> <p>Extended configuration for Redsun application containers.</p> <p>Extends <code>RedSunConfig</code> with component sections used by the application layer. These are not propagated to components.</p> Source code in <code>src/redsun/containers/_config.py</code> <pre><code>class AppConfig(RedSunConfig, total=False):\n    \"\"\"Extended configuration for Redsun application containers.\n\n    Extends [`RedSunConfig`][sunflare.virtual.RedSunConfig`] with component sections\n    used by the application layer. These are **not** propagated to components.\n    \"\"\"\n\n    devices: NotRequired[dict[str, Any]]\n    presenters: NotRequired[dict[str, Any]]\n    views: NotRequired[dict[str, Any]]\n    storage: NotRequired[StorageConfig]\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.StorageConfig","level":2,"title":"<code>StorageConfig</code>","text":"<p>               Bases: <code>RedSunConfig</code></p> <p>Configuration for the storage backend.</p> Source code in <code>src/redsun/containers/_config.py</code> <pre><code>class StorageConfig(RedSunConfig, total=False):\n    \"\"\"Configuration for the storage backend.\"\"\"\n\n    backend: NotRequired[str]\n    \"\"\"Storage backend identifier. Currently only ``\"zarr\"`` is supported.\"\"\"\n\n    base_path: NotRequired[str]\n    \"\"\"Base directory for the store root as a plain filesystem path.\"\"\"\n\n    filename_provider: NotRequired[str]\n    \"\"\"Filename strategy: ``\"auto_increment\"`` (default), ``\"uuid\"``, or ``\"static\"``.\"\"\"\n\n    filename: NotRequired[str]\n    \"\"\"Static filename — only used when *filename_provider* is ``\"static\"``.\"\"\"\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.StorageConfig.backend","level":3,"title":"<code>backend</code>  <code>instance-attribute</code>","text":"<p>Storage backend identifier. Currently only <code>\"zarr\"</code> is supported.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.StorageConfig.base_path","level":3,"title":"<code>base_path</code>  <code>instance-attribute</code>","text":"<p>Base directory for the store root as a plain filesystem path.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.StorageConfig.filename_provider","level":3,"title":"<code>filename_provider</code>  <code>instance-attribute</code>","text":"<p>Filename strategy: <code>\"auto_increment\"</code> (default), <code>\"uuid\"</code>, or <code>\"static\"</code>.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers._config.StorageConfig.filename","level":3,"title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>Static filename — only used when filename_provider is <code>\"static\"</code>.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer","level":2,"title":"<code>QtAppContainer</code>","text":"<p>               Bases: <code>AppContainer</code></p> <p>Application container for Qt-based frontends.</p> <p>Handles the full Qt lifecycle: <code>QApplication</code> creation, container build, <code>QtMainView</code> construction, virtual bus connection, and <code>app.exec()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**config</code> <code>Any</code> <p>Configuration options passed to :meth:<code>AppContainer.__init__</code>.</p> <code>{}</code> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>class QtAppContainer(AppContainer):\n    \"\"\"Application container for Qt-based frontends.\n\n    Handles the full Qt lifecycle: ``QApplication`` creation, container\n    build, ``QtMainView`` construction, virtual bus connection, and\n    ``app.exec()``.\n\n    Parameters\n    ----------\n    **config : Any\n        Configuration options passed to :meth:`AppContainer.__init__`.\n    \"\"\"\n\n    __slots__ = (\"_qt_app\", \"_main_view\")\n\n    def __init__(self, **config: Any) -&gt; None:\n        super().__init__(**config)\n        self._qt_app: QApplication | None = None\n        self._main_view: QtMainView | None = None\n\n    @property\n    def main_view(self) -&gt; QtMainView:\n        \"\"\"Return the main Qt window.\n\n        Raises\n        ------\n        RuntimeError\n            If the application has not been run yet.\n        \"\"\"\n        if self._main_view is None:\n            raise RuntimeError(\"Main view not built. Call run() first.\")\n        return self._main_view\n\n    def build(self) -&gt; QtAppContainer:\n        \"\"\"Ensure a ``QApplication`` exists, then build all components.\n\n        If a ``QApplication`` is not yet running (e.g. when ``build()`` is\n        called explicitly before ``run()``), one is created here so that\n        view components that instantiate ``QWidget`` subclasses have a valid\n        application object available.\n        \"\"\"\n        if self._qt_app is None:\n            self._qt_app = cast(\n                \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n            )\n        super().build()\n        return self\n\n    def run(self) -&gt; NoReturn:\n        \"\"\"Build and launch the Qt application.\"\"\"\n        if self._qt_app is None:\n            self._qt_app = cast(\n                \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n            )\n\n        if not self.is_built:\n            self.build()\n\n        assert self._qt_app is not None  # guaranteed by build() above\n        session_name = self._config.get(\"session\", \"Redsun\")\n        self._main_view = QtMainView(\n            virtual_container=self.virtual_container,\n            session_name=session_name,\n            views=cast(\"dict[str, QtView]\", self.views),\n        )\n\n        # 4. Wire shutdown and start psygnal bridge\n        self._qt_app.aboutToQuit.connect(self.shutdown)\n        start_emitting_from_queue()\n\n        # 6. Show and exec\n        self._main_view.show()\n        sys.exit(self._qt_app.exec())\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.main_view","level":3,"title":"<code>main_view</code>  <code>property</code>","text":"<p>Return the main Qt window.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application has not been run yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.build","level":3,"title":"<code>build()</code>","text":"<p>Ensure a <code>QApplication</code> exists, then build all components.</p> <p>If a <code>QApplication</code> is not yet running (e.g. when <code>build()</code> is called explicitly before <code>run()</code>), one is created here so that view components that instantiate <code>QWidget</code> subclasses have a valid application object available.</p> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>def build(self) -&gt; QtAppContainer:\n    \"\"\"Ensure a ``QApplication`` exists, then build all components.\n\n    If a ``QApplication`` is not yet running (e.g. when ``build()`` is\n    called explicitly before ``run()``), one is created here so that\n    view components that instantiate ``QWidget`` subclasses have a valid\n    application object available.\n    \"\"\"\n    if self._qt_app is None:\n        self._qt_app = cast(\n            \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n        )\n    super().build()\n    return self\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.run","level":3,"title":"<code>run()</code>","text":"<p>Build and launch the Qt application.</p> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>def run(self) -&gt; NoReturn:\n    \"\"\"Build and launch the Qt application.\"\"\"\n    if self._qt_app is None:\n        self._qt_app = cast(\n            \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n        )\n\n    if not self.is_built:\n        self.build()\n\n    assert self._qt_app is not None  # guaranteed by build() above\n    session_name = self._config.get(\"session\", \"Redsun\")\n    self._main_view = QtMainView(\n        virtual_container=self.virtual_container,\n        session_name=session_name,\n        views=cast(\"dict[str, QtView]\", self.views),\n    )\n\n    # 4. Wire shutdown and start psygnal bridge\n    self._qt_app.aboutToQuit.connect(self.shutdown)\n    start_emitting_from_queue()\n\n    # 6. Show and exec\n    self._main_view.show()\n    sys.exit(self._qt_app.exec())\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/changelog/","level":1,"title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Dates are specified in the format <code>DD-MM-YYYY</code>.</p>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#061-20-02-2026","level":2,"title":"0.6.1 - 20-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#fixed","level":3,"title":"Fixed","text":"<ul> <li>Allow multiple widgets to be stacked in the center via <code>QTabWidget</code> for <code>QtAppContainer</code></li> <li>Fix the attribute look-up in loop construction to get the <code>view_position</code> attribute of <code>PView</code></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#060-20-02-2026","level":2,"title":"0.6.0 - 20-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added","level":3,"title":"Added","text":"<ul> <li>Added <code>device()</code>, <code>presenter()</code>, <code>view()</code> typed field specifiers for declarative component registration</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed","level":3,"title":"Changed","text":"<ul> <li><code>IsProvider.register_providers()</code> now runs over both presenters and views</li> <li><code>IsInjectable.inject_dependencies()</code> now runs over both presenters and views</li> <li>Refactored build loop in component construction, provider registration and dependency injection</li> <li><code>_ComponentBase</code>: alias slot removed; name fully resolved at metaclass time</li> <li><code>_PresenterComponent.build()</code>: removed unused container: VirtualContainer parameter</li> <li>All <code>_*Component.build()</code> methods use self.name directly</li> <li>Changed plugin manifest format: from <code>{ class: \"module:Type\" }</code> to flat <code>\"module:Type\"</code> string</li> <li>Updated documentation</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#removed","level":3,"title":"Removed","text":"<ul> <li>Removed <code>component()</code> catch-all field declarator in favor of layer-specific functions</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#056-18-02-2026","level":2,"title":"0.5.6 - 18-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_1","level":3,"title":"Fixed","text":"<ul> <li><code>AppContainer.build()</code> now calls   <code>connect_to_virtual()</code> on all <code>VirtualAware</code> view components after all components are fully constructed, symmetrically   with the existing presenter loop. Previously, views were connected only via a   <code>QtMainView</code> delegator called from <code>QtAppContainer.run()</code>, meaning the wiring   was Qt-specific and bypassed the base build phase entirely.</li> <li>Removed the now-redundant <code>connect_to_virtual()</code> delegator from <code>QtMainView</code>   and the explicit call to it in <code>QtAppContainer.run()</code>.</li> <li>Fixed a spurious warning when a <code>from_config</code> key exists in the YAML but has   no kwargs (bare key with null value, e.g. <code>camera2:</code> with nothing after it).   Previously <code>dict.get()</code> returned <code>None</code> for both a missing key and a null   value, making them indistinguishable. A sentinel is now used so only a   genuinely absent key triggers the warning; a present-but-empty section is   silently normalised to <code>{}</code>.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added_1","level":3,"title":"Added","text":"<ul> <li><code>redsun.qt</code> public namespace exposing <code>QtAppContainer</code> for use in explicit,   developer-written application configurations:   <pre><code>from redsun.qt import QtAppContainer\n</code></pre></li> <li>Clarified documentation</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#054-18-02-2026","level":2,"title":"0.5.4 - 18-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#fixed_2","level":3,"title":"Fixed","text":"<ul> <li>Relaxed the <code>component()</code> overloads: all three (<code>layer=\"device\"</code>, <code>layer=\"presenter\"</code>,   <code>layer=\"view\"</code>) now accept <code>type</code> instead of <code>type[Device]</code>, <code>type[Presenter]</code>,   <code>type[View]</code>. This fixes mypy errors for classes built from protocol mixins that do   not inherit from the sunflare base classes directly.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#053-18-02-2026","level":2,"title":"0.5.3 - 18-02-2026","text":"<p>Warning</p> <p>This release was yanked from PyPI due to a broken distribution</p>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added_2","level":3,"title":"Added","text":"<ul> <li><code>AppContainer</code> and <code>component</code> are now importable directly from the top-level   <code>redsun</code> package:   <pre><code>from redsun import AppContainer, component\n</code></pre></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_1","level":3,"title":"Changed","text":"<ul> <li><code>component()</code> now takes the component class as its first positional argument:   <pre><code># Before\nmotor: MyMotor = component(layer=\"device\", axis=[\"X\"])\n# After\nmotor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n</code></pre></li> <li><code>RedSunConfig</code> removed from the public API; it is an internal <code>TypedDict</code> used   only for YAML configuration validation.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#050-17-02-2026","level":2,"title":"0.5.0 - 17-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_2","level":3,"title":"Changed","text":"<ul> <li>Fully refactor the package to go towards a containerization approach</li> <li>Declare applications as containers, list relevant components as fields of a class</li> <li>Provide support also for building from a configuration file as before</li> <li>Upgrade to <code>sunflare&gt;=0.9.0</code></li> <li>Move the <code>FrontendTypes</code> and <code>ViewPositionTypes</code> from <code>sunflare</code> to <code>redsun</code></li> <li>They're part of the overall configuration and should not concern the core package</li> <li>Revamped documentation with more comprehensive information</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#040-15-12-2025","level":2,"title":"0.4.0 - 15-12-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_3","level":3,"title":"Changed","text":"<ul> <li>Apply a more strict check on imported plugins</li> <li>Add support for 3.13 (simply declared on PyPI and tested via CI)</li> <li>Upgrade to <code>sunflare&gt;=0.7.0</code></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#030-04-07-2025","level":2,"title":"0.3.0 - 04-07-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_4","level":3,"title":"Changed","text":"<ul> <li>Upgraded to <code>sunflare&gt;=0.6.1</code></li> <li>Switch to <code>uv</code></li> <li>Drop support for Python 3.9</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#020-03-03-2025","level":2,"title":"0.2.0 - 03-03-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_5","level":3,"title":"Changed","text":"<ul> <li>Reworked the plugin system</li> <li>The approach now loosely follows the <code>napari</code> manifest, where plugins are to be published via a <code>yaml</code> configuration file in the root folder of the plugin package, specifiying where the classes have to be imported.</li> <li>The manifest is taken as the actual entry point of a plugin, which will be used to redirect to the actual imports which is executed via the standard library <code>importlib</code>.</li> <li>Added additional coverage for the <code>factory</code> module.</li> <li>Bumped sunflare version to <code>sunflare&gt;=0.5.0</code>, which implements the above changes at toolkit level</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#010-22-02-2025","level":2,"title":"0.1.0 - 22-02-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added_3","level":3,"title":"Added","text":"<ul> <li>Initial release on PyPI</li> </ul>","path":["Changelog"],"tags":[]},{"location":"tutorials/","level":1,"title":"Tutorials","text":"<p>Note</p> <p>Tutorials are a work in progress. Please be patient!</p>","path":["Tutorials"],"tags":[]}]}