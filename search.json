{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Redsun","text":"","path":["Redsun"],"tags":[]},{"location":"#redsun","level":1,"title":"Redsun","text":"<p>Event-driven data acquisition software for scientific applications</p> <p>Warning</p> <p>This project is currently under active development and it may (and most likely will) receive breaking changes. Use at your own risk.</p> <p>Redsun is an acquisition software written in CPython, with the concept of building modular user interfaces for scientific data acquisition.</p> <p>It leverages the Bluesky ecosystem to provide a flexible, hardware-agnostic and unopinionated framework for building a control software tailored to the specific needs of different users in different scientific fields.</p> <p>The philosophy of Redsun is to:</p> <ul> <li>not \"reinvent the wheel\", but rather \"ship the tools to build the wheel\";</li> <li>be extensible and modular: pick only the tools you need to get the job done;</li> <li>give the control of your data (and metadata) to you: you decide what is what.</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting started","text":"<ul> <li> <p>Tutorials</p> <p>Learn Redsun from the ground up with step-by-step lessons</p> <p>Start learning </p> </li> <li> <p>How-to guides</p> <p>Practical guides for common tasks and problems</p> <p>Browse guides </p> </li> <li> <p>Reference</p> <p>Technical documentation and API reference</p> <p>View reference </p> </li> <li> <p>Explanation</p> <p>Understand the concepts and design behind Redsun</p> <p>Read explanations </p> </li> </ul>","path":["Redsun"],"tags":[]},{"location":"#quick-links","level":2,"title":"Quick links","text":"<ul> <li>Installation guide - Get Redsun up and running</li> <li>Statement of need - Why Redsun exists</li> <li>API reference - Explore the complete API</li> <li>Changelog - See what's new</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#about-the-documentation","level":2,"title":"About the documentation","text":"<p>This documentation follows the Diataxis framework, organizing content into four distinct categories based on your needs:</p> <ul> <li>Tutorials are learning-oriented lessons</li> <li>How-to guides are task-oriented recipes</li> <li>Reference is information-oriented technical descriptions</li> <li>Explanation is understanding-oriented discussions</li> </ul>","path":["Redsun"],"tags":[]},{"location":"#project-links","level":2,"title":"Project links","text":"<ul> <li>GitHub repository</li> <li>PyPI package</li> <li>Sunflare SDK</li> </ul>","path":["Redsun"],"tags":[]},{"location":"explanation/","level":1,"title":"Explanation","text":"<p>Explanations are understanding-oriented discussions that clarify and illuminate a topic. They provide context, discuss alternatives, and explain the \"why\" behind design decisions.</p> <ul> <li>Statement of need - Why Redsun exists and its role in the scientific software ecosystem</li> </ul>","path":["Explanation"],"tags":[]},{"location":"explanation/#architecture-design","level":3,"title":"Architecture &amp; design","text":"<ul> <li>Container architecture - The container-based MVP architecture and component system</li> <li>Plugin system - How plugins are discovered, loaded, and integrated</li> </ul>","path":["Explanation"],"tags":[]},{"location":"explanation/#deepen-your-understanding","level":2,"title":"Deepen your understanding","text":"<ul> <li>For hands-on learning, try the Tutorials</li> <li>For practical tasks, see the How-to guides</li> <li>For technical details, check the API reference</li> </ul>","path":["Explanation"],"tags":[]},{"location":"explanation/container-architecture/","level":1,"title":"Container architecture","text":"<p>Redsun uses a container-based Model-View-Presenter (MVP) architecture to manage the lifecycle and dependencies of application components.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#overview","level":2,"title":"Overview","text":"<p>At the core of Redsun is the <code>AppContainer</code>, which acts as the central registry and build system for all application components. Components are declared as class attributes and instantiated in a well-defined dependency order.</p> <pre><code>graph LR\n    subgraph 1. Create infrastructure\n        VirtualBus\n        DI[DI Container]\n    end\n\n    subgraph 2. Build components\n        Devices\n        Presenters\n        Views\n    end\n\n    Devices --&gt; Presenters\n    Presenters --&gt; Views\n    VirtualBus --&gt; Presenters\n    VirtualBus --&gt; Views\n    Presenters -.-&gt;|register providers| DI\n    DI -.-&gt;|inject dependencies| Views</code></pre>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#the-mvp-pattern","level":2,"title":"The MVP pattern","text":"<p>Redsun follows the Model-View-Presenter pattern provided by Sunflare:</p> <ul> <li>Model (Devices): hardware abstractions that implement Bluesky's device protocols via <code>Device</code>. They represent the actual instruments being controlled.</li> <li>View: UI components (currently Qt-based) that implement <code>View</code> to display data and capture user interactions.</li> <li>Presenter: business logic components that implement <code>Presenter</code>, sitting between models and views, coordinating device operations and updating the UI through the virtual bus.</li> </ul> <p>This separation ensures that hardware drivers, UI components, and business logic can be developed and tested independently.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#declarative-component-registration","level":2,"title":"Declarative component registration","text":"<p><code>redsun</code> operates on a bring-your-own components approach. Each component is intended to be developed separately and in isolation or as part of bundles of multiple components that can by dynamically assembled. In a declarative manner, this means importing the components explicitly and assigning them to a container.</p> <p>Components are declared as class attributes using the <code>component()</code> field specifier, passing the component class as the first argument. When writing a container explicitly, you inherit from the frontend-specific subclass rather than the base <code>AppContainer</code> — for Qt applications that is <code>QtAppContainer</code>:</p> <pre><code>from redsun import component\nfrom redsun.qt import QtAppContainer\n\n\ndef my_app() -&gt; None:\n    class MyApp(QtAppContainer):\n        motor = component(MyMotor, layer=\"device\", axis=[\"X\", \"Y\"])\n        ctrl = component(MyController, layer=\"presenter\", gain=1.0)\n        ui = component(MyView, layer=\"view\")\n\n    MyApp().run()\n</code></pre> <p>The class is defined inside a function so that the Qt imports and any heavy device imports are deferred until the application is actually launched.</p> <p>The <code>AppContainerMeta</code> metaclass collects these declarations at class creation time. Because the class is passed directly to <code>component()</code>, no annotation inspection is needed. This declarative approach allows the container to:</p> <ul> <li>validate component types at class creation time;</li> <li>inherit and override components from base classes;</li> <li>merge configuration from YAML files with inline keyword arguments.</li> </ul>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#configuration-file-support","level":2,"title":"Configuration file support","text":"<p>Components can pull their keyword arguments from a YAML configuration file by passing <code>config=</code> to the class definition and <code>from_config=</code> to each <code>component()</code> call:</p> <pre><code>from redsun import component\nfrom redsun.qt import QtAppContainer\n\n\ndef my_app() -&gt; None:\n    class MyApp(QtAppContainer, config=\"app_config.yaml\"):\n        motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n        ctrl = component(MyController, layer=\"presenter\", from_config=\"ctrl\")\n        ui = component(MyView, layer=\"view\", from_config=\"ui\")\n\n    MyApp().run()\n</code></pre> <p>The configuration file provides base keyword arguments for each component. These can be selectively overridden by inline keyword arguments in the <code>component()</code> call, allowing the same container class to be reused across different hardware setups by swapping configuration files.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#build-order","level":2,"title":"Build order","text":"<p>When <code>build()</code> is called, the container instantiates components in a strict dependency order:</p> <ol> <li>VirtualBus - the event-driven communication channel (<code>VirtualBus</code>).</li> <li>DI container - the dependency injection container, seeded with the application configuration.</li> <li>Devices - hardware interfaces, each receiving their name and keyword arguments.</li> <li>Presenters - business logic components, receiving the full device dictionary and virtual bus. Presenters that implement <code>IsProvider</code> register their providers in the DI container.</li> <li>Views - UI components, receiving the virtual bus. Views that implement <code>IsInjectable</code> receive dependencies from the DI container.</li> </ol>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#communication","level":2,"title":"Communication","text":"<p>Components communicate through two mechanisms:</p> <ul> <li>Virtual bus: an event-driven publish/subscribe system provided by <code>sunflare</code> (<code>VirtualBus</code>). Presenters and views can emit and listen for signals without direct references to each other.</li> <li>Dependency injection: presenters can register providers in the DI container, and views can consume them. This allows views to access presenter-provided data without coupling to specific presenter implementations.</li> </ul>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#two-usage-flows","level":2,"title":"Two usage flows","text":"<p>Redsun supports two distinct approaches for assembling an application, both producing the same result at runtime.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#explicit-flow-developer-written-containers","level":3,"title":"Explicit flow (developer-written containers)","text":"<p>The explicit flow is for plugin bundle authors who know exactly which components they need and which frontend they target. The container subclass, component classes, and frontend are all fixed at write time:</p> <pre><code>from redsun import component\nfrom redsun.qt import QtAppContainer\n\n# these are user-developed classes\n# that should reflect the structure\n# provided by sunflare for each layer\nfrom my_package.device import MyMotor\nfrom my_package.presenter import MyPresenter\nfrom my_package.view import MyView\n\n\ndef my_app() -&gt; None:\n    class MyApp(QtAppContainer, config=\"config.yaml\"):\n        motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n        ctrl = component(MyPresenter, layer=\"presenter\", from_config=\"ctrl\")\n        ui = component(MyView, layer=\"view\", from_config=\"ui\")\n\n    MyApp().run()\n</code></pre> <p>The class is defined inside a function so that Qt imports (and any heavy device imports) are deferred until the function is actually called. <code>QtAppContainer</code> is imported from the public <code>redsun.qt</code> namespace.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#dynamic-flow-configuration-driven","level":3,"title":"Dynamic flow (configuration-driven)","text":"<p>The dynamic flow is for end users who point Redsun at a YAML configuration file. Plugins are discovered via entry points and the frontend is resolved from the <code>frontend:</code> key in the file — no Python code needs to be written:</p> <pre><code>from redsun import AppContainer\n\napp = AppContainer.from_config(\"path/to/config.yaml\")\napp.run()\n</code></pre> <p>The YAML file drives everything:</p> <pre><code>schema: 1.0\nsession: \"My Experiment\"\nfrontend: \"pyqt\"\n\ndevices:\n  motor:\n    plugin_name: my-plugin\n    plugin_id: my_motor\n</code></pre> <p>See the plugin system documentation for a full description of the dynamic flow.</p>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/container-architecture/#qt-integration","level":2,"title":"Qt integration","text":"<p><code>QtAppContainer</code> extends <code>AppContainer</code> with the full Qt lifecycle:</p> <ol> <li>Creates the <code>QApplication</code> instance.</li> <li>Calls <code>build()</code> to instantiate all components.</li> <li>Constructs the <code>QtMainView</code> main window and docks all views.</li> <li>Connects <code>VirtualAware</code> views to the virtual bus.</li> <li>Starts the <code>psygnal</code> signal queue bridge for thread-safe signal delivery.</li> <li>Shows the main window and enters the Qt event loop.</li> </ol> <p>It is imported from the public <code>redsun.qt</code> namespace:</p> <pre><code>from redsun.qt import QtAppContainer\n</code></pre>","path":["Explanation","Container architecture"],"tags":[]},{"location":"explanation/plugin-system/","level":1,"title":"Plugin system","text":"<p>Redsun's plugin system allows third-party packages to provide devices, presenters, and views that are dynamically discovered and loaded at runtime.</p>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#overview","level":2,"title":"Overview","text":"<p>Plugins are standard Python packages that register themselves via entry points. When Redsun builds an application from a YAML configuration file, it uses these entry points to discover available plugins and load the requested components.</p> <pre><code>graph TB\n    Config[YAML config] --&gt;|references| Plugins\n    Plugins --&gt;|discovered via| EntryPoints[entry points]\n    EntryPoints --&gt;|load| Manifest[plugin manifest]\n    Manifest --&gt;|resolves to| Classes[component classes]\n    Classes --&gt;|registered in| Container[AppContainer]</code></pre>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#plugin-discovery","level":2,"title":"Plugin discovery","text":"<p>When <code>AppContainer.from_config()</code> is called with a configuration file, Redsun:</p> <ol> <li>Reads the configuration - parses the YAML file to determine which devices, presenters, and views are needed.</li> <li>Queries entry points - looks up installed packages registered under the <code>redsun.plugins</code> entry point group.</li> <li>Loads manifests - each plugin provides a YAML manifest file that maps plugin IDs to their Python class locations.</li> <li>Validates protocols - each loaded class is checked against the expected protocol (Device, Presenter, or View).</li> <li>Creates the container - a dynamic container class is assembled with the discovered components.</li> </ol>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#plugin-manifest","level":2,"title":"Plugin manifest","text":"<p>Each plugin package includes a YAML manifest file that declares the available components:</p> <pre><code>devices:\n  my_motor:\n    class: \"my_plugin.devices:MyMotor\"\n\npresenters:\n  my_controller:\n    class: \"my_plugin.presenters:MyController\"\n\nviews:\n  my_ui:\n    class: \"my_plugin.views:MyView\"\n</code></pre> <p>The manifest is registered as a Python entry point in the plugin's <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"redsun.plugins\"]\nmy-plugin = \"manifest.yaml\"\n</code></pre>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#configuration-file-format","level":2,"title":"Configuration file format","text":"<p>The application configuration file references plugins by name and ID:</p> <pre><code>schema: 1.0\nsession: \"My Experiment\"\nfrontend: \"pyqt\"\n\ndevices:\n  motor:\n    plugin_name: my-plugin\n    plugin_id: my_motor\n    axis:\n      - X\n      - Y\n\npresenters:\n  controller:\n    plugin_name: my-plugin\n    plugin_id: my_controller\n\nviews:\n  ui:\n    plugin_name: my-plugin\n    plugin_id: my_ui\n</code></pre> <p>The <code>plugin_name</code> and <code>plugin_id</code> keys are used for plugin resolution and are not passed to the component constructors. All other keys become keyword arguments for the component.</p>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#protocol-validation","level":2,"title":"Protocol validation","text":"<p>Before a plugin class is used, Redsun verifies it implements the expected protocol:</p> <ul> <li>Devices must be subclasses of <code>Device</code> or implement <code>read_configuration</code>, <code>describe_configuration</code>, <code>name</code>, and <code>parent</code>.</li> <li>Presenters must be subclasses of <code>Presenter</code> or have <code>devices</code> and <code>virtual_bus</code> attributes.</li> <li>Views must be subclasses of <code>View</code> or have a <code>virtual_bus</code> attribute.</li> </ul> <p>Classes that satisfy the protocol structurally (without inheriting from the base class) are registered as virtual subclasses via <code>ABCMeta.register()</code>.</p>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/plugin-system/#inline-vs-config-based-registration","level":2,"title":"Inline vs. config-based registration","text":"<p>The plugin system is used when building from configuration files via <code>AppContainer.from_config()</code>. When using the declarative class-based approach (defining a container subclass with <code>component()</code> fields), component classes are passed directly as the first argument to <code>component()</code> and do not go through plugin discovery.</p> <p>Both approaches produce the same result: an <code>AppContainer</code> with registered device, presenter, and view components ready to be built.</p>","path":["Explanation","Plugin system"],"tags":[]},{"location":"explanation/statement/","level":1,"title":"Statement of need","text":"<p>Scientific data acquisition often involves controlling a variety of hardware devices, coordinating measurements, and managing the resulting data and metadata. While the Bluesky ecosystem provides a powerful hardware abstraction layer and data model, building a complete application that integrates these capabilities into a usable interface remains a non-trivial task.</p> <p>Redsun addresses this gap by providing a modular, event-driven framework for constructing scientific data acquisition applications.</p> <pre><code>graph TD\n    Sunflare --&gt;|provides SDK| Plugins\n    Sunflare --&gt;|provides SDK| Redsun\n    Plugins --&gt;|loaded by| Redsun\n    Redsun --&gt;|assembles| Application</code></pre>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#the-role-of-each-component","level":2,"title":"The role of each component","text":"<ul> <li>Sunflare is the Software Development Kit (SDK) that provides shared base classes and communication patterns (devices, presenters, views, virtual bus). It ensures a consistent programming model across the entire ecosystem.</li> <li>Plugins are user-developed packages that implement the actual hardware drivers, business logic, and UI components using Sunflare's abstractions.</li> <li>Redsun is the application shell that discovers plugins, wires them together through its container architecture, and launches the final application.</li> </ul>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#design-philosophy","level":2,"title":"Design philosophy","text":"<p>Redsun follows three guiding principles:</p> <ol> <li>Don't reinvent the wheel - leverage existing tools like Bluesky's hardware protocols and Qt's UI framework. Instead of building everything from scratch, ship the tools to build the wheel.</li> <li>Be modular - users should be able to pick only the components they need. A plugin providing a motor controller should work independently of one providing a camera interface.</li> <li>Give users control - users own their data and metadata. The framework provides the structure but does not impose constraints on what data means or how it should be organized.</li> </ol>","path":["Explanation","Statement of need"],"tags":[]},{"location":"explanation/statement/#why-not-just-use-bluesky-directly","level":2,"title":"Why not just use Bluesky directly?","text":"<p>Bluesky excels at hardware abstraction and experiment orchestration, but it does not provide:</p> <ul> <li>a graphical user interface framework;</li> <li>a plugin system for composing applications from independent packages;</li> <li>a container architecture for managing component lifecycles and dependencies;</li> <li>an event-driven communication layer between UI and business logic.</li> </ul> <p>Redsun fills these gaps while staying fully compatible with the Bluesky data model and message protocol.</p>","path":["Explanation","Statement of need"],"tags":[]},{"location":"how-to/","level":1,"title":"How-to guides","text":"<p>How-to guides are task-oriented recipes that guide you through the steps involved in solving a specific problem or accomplishing a specific task. They assume some basic knowledge of Redsun.</p>","path":["How-to guides"],"tags":[]},{"location":"how-to/#available-guides","level":2,"title":"Available guides","text":"","path":["How-to guides"],"tags":[]},{"location":"how-to/#getting-started","level":3,"title":"Getting started","text":"<ul> <li>Installation - How to install Redsun in different environments</li> <li>Build documentation - How to build the documentation locally</li> <li>Run tests - How to run the test suite and generate coverage reports</li> </ul>","path":["How-to guides"],"tags":[]},{"location":"how-to/#need-help","level":2,"title":"Need help?","text":"<ul> <li>If you're new to Redsun, start with the Tutorials</li> <li>For conceptual understanding, see the Explanation section</li> <li>For detailed technical information, check the API reference</li> </ul>","path":["How-to guides"],"tags":[]},{"location":"how-to/build-docs/","level":1,"title":"Build documentation","text":"<p>This guide covers how to build the Redsun documentation locally.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed Redsun with development dependencies.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#build-with-zensical","level":2,"title":"Build with Zensical","text":"<p>Build the documentation from the project root:</p> <pre><code>uv run zensical build\n</code></pre> <p>The built documentation will be in the <code>site/</code> directory. Open <code>site/index.html</code> in your browser to view it.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#serve-documentation-locally","level":2,"title":"Serve documentation locally","text":"<p>For development, serve the documentation with live reload:</p> <pre><code>uv run zensical serve\n</code></pre> <p>This starts a local server at <code>http://localhost:8000</code> and automatically rebuilds when you make changes.</p>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#missing-dependencies","level":3,"title":"Missing dependencies","text":"<p>If you get errors about missing dependencies:</p> <pre><code>uv sync\n</code></pre>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#port-already-in-use","level":3,"title":"Port already in use","text":"<p>If port 8000 is already in use, specify a different port:</p> <pre><code>uv run zensical serve --dev-addr localhost:8080\n</code></pre>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/build-docs/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Learn how to run tests</li> <li>Read about Redsun's architecture</li> </ul>","path":["How-to guides","Build documentation"],"tags":[]},{"location":"how-to/installation/","level":1,"title":"Installation","text":"<p>This guide covers how to install Redsun in different environments.</p>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#create-a-virtual-environment","level":2,"title":"Create a virtual environment","text":"<p>It is recommended to install the package in a virtual environment.</p> uv (recommended)venvcondamamba <pre><code>uv venv --python 3.10\n\n# For Linux/macOS\nsource .venv/bin/activate\n\n# For Windows Command Prompt\n.venv\\Scripts\\activate.bat\n\n# For Windows PowerShell\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code># Python version depends on the globally installed Python\npython -m venv redsun-env\n\n# For Linux/macOS\nsource redsun-env/bin/activate\n\n# For Windows Command Prompt\nredsun-env\\Scripts\\activate.bat\n\n# For Windows PowerShell\nredsun-env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>conda create -n redsun-env python=3.10\nconda activate redsun-env\n</code></pre> <pre><code>mamba create -n redsun-env python=3.10\nmamba activate redsun-env\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#install-redsun","level":2,"title":"Install Redsun","text":"<p>The package is available on PyPI or directly from the GitHub repository.</p> PyPIGitHub (development) <pre><code>pip install -U redsun\n\n# Or if you're using uv\nuv pip install redsun\n</code></pre> <pre><code>git clone https://github.com/redsun-acquisition/redsun.git\ncd redsun\npip install -e .\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#qt-backend","level":3,"title":"Qt backend","text":"<p>Redsun requires a Qt backend. Install with your preferred binding:</p> PyQt6PySide6 <pre><code>pip install redsun[pyqt]\n</code></pre> <pre><code>pip install redsun[pyside]\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#install-development-dependencies","level":2,"title":"Install development dependencies","text":"<p>If you are contributing to Redsun or want to run tests locally, install the development dependencies via PEP-735 dependency groups.</p> uv (recommended)pip <pre><code>uv sync\n</code></pre> <pre><code>pip install -e .[dev]\n</code></pre>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/installation/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Learn how to build the documentation</li> <li>Learn how to run tests</li> <li>Check out the tutorials to get started with Redsun</li> </ul>","path":["How-to guides","Installation"],"tags":[]},{"location":"how-to/run-tests/","level":1,"title":"Run tests","text":"<p>This guide covers how to run the Redsun test suite and generate coverage reports.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Make sure you have installed Redsun with development dependencies.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-all-tests","level":2,"title":"Run all tests","text":"<p>Run the tests from the project root:</p> <pre><code>pytest\n</code></pre>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#generate-coverage-report","level":2,"title":"Generate coverage report","text":"<p>Obtain a test coverage report:</p> <pre><code>pytest --cov=redsun --cov-report=html\n</code></pre> <p>This generates an <code>htmlcov/</code> directory. Open <code>htmlcov/index.html</code> in your browser to view it.</p>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#run-specific-tests","level":2,"title":"Run specific tests","text":"<pre><code># Run a specific test file\npytest tests/test_config.py\n\n# Run a specific test function\npytest tests/test_config.py::test_function_name\n\n# Run tests matching a pattern\npytest -k \"test_container\"\n</code></pre>","path":["How-to guides","Run tests"],"tags":[]},{"location":"how-to/run-tests/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Learn how to build the documentation</li> <li>Understand Redsun's container architecture</li> <li>Check the API reference</li> </ul>","path":["How-to guides","Run tests"],"tags":[]},{"location":"reference/","level":1,"title":"Reference","text":"<ul> <li>API reference - Public API</li> <li>Changelog - Version history and release notes</li> </ul>","path":["Reference"],"tags":[]},{"location":"reference/api/","level":1,"title":"API reference","text":"","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.config","level":2,"title":"<code>config</code>","text":"<p>Application-level configuration enums for redsun.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.config.FrontendTypes","level":3,"title":"<code>FrontendTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported frontend types.</p> <p>Attributes:</p> Name Type Description <code>PYQT</code> <code>str</code> <p>PyQt6 frontend.</p> <code>PYSIDE</code> <code>str</code> <p>PySide6 frontend.</p> Source code in <code>src/redsun/config.py</code> <pre><code>@unique\nclass FrontendTypes(str, Enum):\n    \"\"\"Supported frontend types.\n\n    Attributes\n    ----------\n    PYQT : str\n        PyQt6 frontend.\n    PYSIDE : str\n        PySide6 frontend.\n    \"\"\"\n\n    PYQT = \"pyqt\"\n    PYSIDE = \"pyside\"\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.config.ViewPositionTypes","level":3,"title":"<code>ViewPositionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported view position types.</p> <p>Used to define the position of a view component in the main view of the GUI.</p> <p>Warning</p> <p>These values are based on how Qt manages dock widgets. They may change in the future.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Center view position.</p> <code>LEFT</code> <code>str</code> <p>Left view position.</p> <code>RIGHT</code> <code>str</code> <p>Right view position.</p> <code>TOP</code> <code>str</code> <p>Top view position.</p> <code>BOTTOM</code> <code>str</code> <p>Bottom view position.</p> Source code in <code>src/redsun/config.py</code> <pre><code>@unique\nclass ViewPositionTypes(str, Enum):\n    \"\"\"Supported view position types.\n\n    Used to define the position of a view component in the main view of the GUI.\n\n    !!! warning\n        These values are based on how Qt manages dock widgets.\n        They may change in the future.\n\n    Attributes\n    ----------\n    CENTER : str\n        Center view position.\n    LEFT : str\n        Left view position.\n    RIGHT : str\n        Right view position.\n    TOP : str\n        Top view position.\n    BOTTOM : str\n        Bottom view position.\n    \"\"\"\n\n    CENTER = \"center\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components","level":2,"title":"<code>components</code>","text":"","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.components.component","level":3,"title":"<code>component(cls, *, layer, alias=None, from_config=None, **kwargs)</code>","text":"<pre><code>component(\n    cls: type,\n    *,\n    layer: Literal[\"device\"],\n    alias: str | None = ...,\n    from_config: str | None = ...,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre><pre><code>component(\n    cls: type,\n    *,\n    layer: Literal[\"presenter\"],\n    alias: None = ...,\n    from_config: str | None = ...,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre><pre><code>component(\n    cls: type,\n    *,\n    layer: Literal[\"view\"],\n    alias: None = ...,\n    from_config: str | None = ...,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Declare a component as a class field.</p> <p>This function is a field specifier for use with <code>~redsun.containers.AppContainer</code> subclasses.  The component class is passed directly as the first argument, and the attribute name becomes the component name.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to instantiate. For <code>layer=\"device\"</code> this must be a <code>Device</code> subclass. For <code>layer=\"presenter\"</code> and <code>layer=\"view\"</code> any class with the appropriate constructor signature is accepted, including protocol-based implementations that do not inherit from <code>Presenter</code> or <code>View</code> directly.</p> required <code>layer</code> <code>'device' | 'presenter' | 'view'</code> <p>The layer this component belongs to.</p> required <code>alias</code> <code>str | None</code> <p>For device components only: an alternative name to pass to the device constructor instead of the attribute name. Ignored for presenters and views. Defaults to <code>None</code>.</p> <code>None</code> <code>from_config</code> <code>str | None</code> <p>The key to look up in the configuration file's <code>devices</code>, <code>presenters</code>, or <code>views</code> section (based on <code>layer</code>). If <code>None</code>, kwargs must be specified inline. Defaults to <code>None</code>.</p> <code>None</code> <code>**kwargs</code> <code>`Any`</code> <p>Additional keyword arguments forwarded to the component constructor at build time. These override values from the configuration file if <code>from_config</code> is set.</p> <code>{}</code> <p>Returns:</p> Type Description <code>`Any`</code> <p>A <code>_ComponentField</code> sentinel (typed as <code>Any</code> so that the attribute assignment satisfies type checkers).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyApp(AppContainer):\n...     motor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n...     ctrl = component(MyCtrl, layer=\"presenter\", gain=1.0)\n...     ui = component(MyView, layer=\"view\")\n</code></pre> <p>With a config file:</p> <pre><code>&gt;&gt;&gt; class MyApp(AppContainer, config=\"app_config.yaml\"):\n...     motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n</code></pre> Source code in <code>src/redsun/containers/components.py</code> <pre><code>def component(\n    cls: type,\n    *,\n    layer: Literal[\"device\", \"presenter\", \"view\"],\n    alias: str | None = None,\n    from_config: str | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Declare a component as a class field.\n\n    This function is a field specifier for use with\n    `~redsun.containers.AppContainer` subclasses.  The component class\n    is passed directly as the first argument, and the attribute name\n    becomes the component name.\n\n    Parameters\n    ----------\n    cls : type\n        The component class to instantiate. For ``layer=\"device\"`` this\n        must be a `Device` subclass. For ``layer=\"presenter\"`` and\n        ``layer=\"view\"`` any class with the appropriate constructor\n        signature is accepted, including protocol-based implementations\n        that do not inherit from `Presenter` or `View` directly.\n    layer : \"device\" | \"presenter\" | \"view\"\n        The layer this component belongs to.\n    alias : str | None\n        For device components only: an alternative name to pass to the\n        device constructor instead of the attribute name. Ignored for\n        presenters and views. Defaults to `None`.\n    from_config : str | None\n        The key to look up in the configuration file's ``devices``,\n        ``presenters``, or ``views`` section (based on ``layer``).\n        If `None`, kwargs must be specified inline. Defaults to `None`.\n    **kwargs : `Any`\n        Additional keyword arguments forwarded to the component\n        constructor at build time. These override values from the\n        configuration file if ``from_config`` is set.\n\n    Returns\n    -------\n    `Any`\n        A `_ComponentField` sentinel (typed as `Any` so that the\n        attribute assignment satisfies type checkers).\n\n    Examples\n    --------\n    &gt;&gt;&gt; class MyApp(AppContainer):\n    ...     motor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n    ...     ctrl = component(MyCtrl, layer=\"presenter\", gain=1.0)\n    ...     ui = component(MyView, layer=\"view\")\n\n    With a config file:\n\n    &gt;&gt;&gt; class MyApp(AppContainer, config=\"app_config.yaml\"):\n    ...     motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n    \"\"\"\n    return _ComponentField(\n        cls=cls, layer=layer, alias=alias, from_config=from_config, kwargs=kwargs\n    )\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainerMeta","level":2,"title":"<code>AppContainerMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass that auto-collects component wrappers from class attributes.</p> <p>When a new class is created with this metaclass, it scans the namespace for <code>_DeviceComponent</code>, <code>_PresenterComponent</code>, and <code>_ViewComponent</code> instances, collecting them into class-level dictionaries.  Components from base classes are inherited and can be overridden.</p> <p>Annotated fields using <code>component</code> are also resolved: the type annotation provides the component class and the attribute name becomes the component name.</p> <p>A configuration file can be specified at metaclass level, which allows component fields to pull their kwargs from the config.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>class AppContainerMeta(type):\n    \"\"\"Metaclass that auto-collects component wrappers from class attributes.\n\n    When a new class is created with this metaclass, it scans the namespace\n    for `_DeviceComponent`, `_PresenterComponent`, and\n    `_ViewComponent` instances, collecting them into class-level\n    dictionaries.  Components from base classes are inherited and can be\n    overridden.\n\n    Annotated fields using `component` are also resolved: the type\n    annotation provides the component class and the attribute name becomes\n    the component name.\n\n    A configuration file can be specified at metaclass level,\n    which allows component fields to pull their kwargs from the config.\n    \"\"\"\n\n    _device_components: dict[str, _DeviceComponent]\n    _presenter_components: dict[str, _PresenterComponent]\n    _view_components: dict[str, _ViewComponent]\n    _config_path: Path | None\n\n    def __new__(\n        mcs,\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        config: str | Path | None = None,\n        **kwargs: Any,\n    ) -&gt; AppContainerMeta:\n        \"\"\"Create the class and collect component wrappers.\n\n        Parameters\n        ----------\n        config : str | Path | None\n            Path to a YAML configuration file for component kwargs. Passed when\n            defining the subclass:\n\n                class MyApp(AppContainer, config=\"app.yaml\"): ...\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace, **kwargs)\n\n        # Store config path on the class\n        config_path: Path | None = None\n        if config is not None:\n            config_path = Path(config)\n        else:\n            # Check base classes for an inherited config path\n            for base in bases:\n                if hasattr(base, \"_config_path\") and base._config_path is not None:\n                    if isinstance(base._config_path, str):\n                        config_path = Path(base._config_path)\n                    elif isinstance(base._config_path, Path):\n                        config_path = base._config_path\n                    config_path = base._config_path\n                    break\n        cls._config_path = config_path\n\n        # Inherit components from base classes\n        devices: dict[str, _DeviceComponent] = {}\n        presenters: dict[str, _PresenterComponent] = {}\n        views: dict[str, _ViewComponent] = {}\n\n        for base in bases:\n            if hasattr(base, \"_device_components\"):\n                devices.update(base._device_components)\n            if hasattr(base, \"_presenter_components\"):\n                presenters.update(base._presenter_components)\n            if hasattr(base, \"_view_components\"):\n                views.update(base._view_components)\n\n        # Overlay with explicit component wrappers declared in current namespace\n        for attr_name, attr_value in namespace.items():\n            if attr_name.startswith(\"_\"):\n                continue\n\n            if isinstance(attr_value, _DeviceComponent):\n                devices[attr_value.name] = attr_value\n            elif isinstance(attr_value, _PresenterComponent):\n                presenters[attr_value.name] = attr_value\n            elif isinstance(attr_value, _ViewComponent):\n                views[attr_value.name] = attr_value\n\n        # Resolve component() field declarations from the namespace.\n        # The class is carried directly on the _ComponentField, so no\n        # annotation inspection or get_type_hints() call is needed.\n        component_fields = {\n            attr_name: value\n            for attr_name, value in namespace.items()\n            if not attr_name.startswith(\"_\") and isinstance(value, _ComponentField)\n        }\n\n        if component_fields:\n            # Load container-level config if a config path is present\n            config_data: dict[str, Any] = {}\n            if config_path is not None:\n                config_data = _load_yaml(config_path)\n\n            for attr_name, field in component_fields.items():\n                # Merge kwargs: config file values as base, inline as override\n                kwargs = field.kwargs\n                if field.from_config is not None:\n                    if not config_data:\n                        raise TypeError(\n                            f\"Component field '{attr_name}' in {name} has \"\n                            f\"from_config set but no config path was \"\n                            f\"provided to the container class\"\n                        )\n\n                    # Map layer to config section key\n                    layer_to_section = {\n                        \"device\": \"devices\",\n                        \"presenter\": \"presenters\",\n                        \"view\": \"views\",\n                    }\n                    section_key = layer_to_section[field.layer]\n                    section_data: dict[str, Any] = config_data.get(section_key, {})\n                    cfg_section = section_data.get(field.from_config)\n\n                    if cfg_section is None:\n                        logger.warning(\n                            f\"No config section '{field.from_config}' found in \"\n                            f\"'{section_key}' for component field '{attr_name}' in {name}, \"\n                            f\"using inline kwargs only\"\n                        )\n                        kwargs = field.kwargs\n                    else:\n                        kwargs = {**cfg_section, **field.kwargs}\n\n                wrapper: _DeviceComponent | _PresenterComponent | _ViewComponent\n                match field.layer:\n                    case \"device\":\n                        wrapper = _DeviceComponent(\n                            field.cls, attr_name, field.alias, **kwargs\n                        )\n                        devices[attr_name] = wrapper\n                    case \"presenter\":\n                        wrapper = _PresenterComponent(\n                            field.cls, attr_name, None, **kwargs\n                        )\n                        presenters[attr_name] = wrapper\n                    case \"view\":\n                        wrapper = _ViewComponent(field.cls, attr_name, None, **kwargs)\n                        views[attr_name] = wrapper\n                    case _:\n                        _assert_never(field.layer)\n                setattr(cls, attr_name, wrapper)\n\n        cls._device_components = devices\n        cls._presenter_components = presenters\n        cls._view_components = views\n\n        if devices or presenters or views:\n            logger.debug(\n                f\"Collected from {name}: \"\n                f\"{len(devices)} devices, \"\n                f\"{len(presenters)} presenters, \"\n                f\"{len(views)} views\"\n            )\n\n        return cls\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainerMeta.__new__","level":3,"title":"<code>__new__(mcs, name, bases, namespace, config=None, **kwargs)</code>","text":"<p>Create the class and collect component wrappers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str | Path | None</code> <p>Path to a YAML configuration file for component kwargs. Passed when defining the subclass:</p> <pre><code>class MyApp(AppContainer, config=\"app.yaml\"): ...\n</code></pre> <code>None</code> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def __new__(\n    mcs,\n    name: str,\n    bases: tuple[type, ...],\n    namespace: dict[str, Any],\n    config: str | Path | None = None,\n    **kwargs: Any,\n) -&gt; AppContainerMeta:\n    \"\"\"Create the class and collect component wrappers.\n\n    Parameters\n    ----------\n    config : str | Path | None\n        Path to a YAML configuration file for component kwargs. Passed when\n        defining the subclass:\n\n            class MyApp(AppContainer, config=\"app.yaml\"): ...\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace, **kwargs)\n\n    # Store config path on the class\n    config_path: Path | None = None\n    if config is not None:\n        config_path = Path(config)\n    else:\n        # Check base classes for an inherited config path\n        for base in bases:\n            if hasattr(base, \"_config_path\") and base._config_path is not None:\n                if isinstance(base._config_path, str):\n                    config_path = Path(base._config_path)\n                elif isinstance(base._config_path, Path):\n                    config_path = base._config_path\n                config_path = base._config_path\n                break\n    cls._config_path = config_path\n\n    # Inherit components from base classes\n    devices: dict[str, _DeviceComponent] = {}\n    presenters: dict[str, _PresenterComponent] = {}\n    views: dict[str, _ViewComponent] = {}\n\n    for base in bases:\n        if hasattr(base, \"_device_components\"):\n            devices.update(base._device_components)\n        if hasattr(base, \"_presenter_components\"):\n            presenters.update(base._presenter_components)\n        if hasattr(base, \"_view_components\"):\n            views.update(base._view_components)\n\n    # Overlay with explicit component wrappers declared in current namespace\n    for attr_name, attr_value in namespace.items():\n        if attr_name.startswith(\"_\"):\n            continue\n\n        if isinstance(attr_value, _DeviceComponent):\n            devices[attr_value.name] = attr_value\n        elif isinstance(attr_value, _PresenterComponent):\n            presenters[attr_value.name] = attr_value\n        elif isinstance(attr_value, _ViewComponent):\n            views[attr_value.name] = attr_value\n\n    # Resolve component() field declarations from the namespace.\n    # The class is carried directly on the _ComponentField, so no\n    # annotation inspection or get_type_hints() call is needed.\n    component_fields = {\n        attr_name: value\n        for attr_name, value in namespace.items()\n        if not attr_name.startswith(\"_\") and isinstance(value, _ComponentField)\n    }\n\n    if component_fields:\n        # Load container-level config if a config path is present\n        config_data: dict[str, Any] = {}\n        if config_path is not None:\n            config_data = _load_yaml(config_path)\n\n        for attr_name, field in component_fields.items():\n            # Merge kwargs: config file values as base, inline as override\n            kwargs = field.kwargs\n            if field.from_config is not None:\n                if not config_data:\n                    raise TypeError(\n                        f\"Component field '{attr_name}' in {name} has \"\n                        f\"from_config set but no config path was \"\n                        f\"provided to the container class\"\n                    )\n\n                # Map layer to config section key\n                layer_to_section = {\n                    \"device\": \"devices\",\n                    \"presenter\": \"presenters\",\n                    \"view\": \"views\",\n                }\n                section_key = layer_to_section[field.layer]\n                section_data: dict[str, Any] = config_data.get(section_key, {})\n                cfg_section = section_data.get(field.from_config)\n\n                if cfg_section is None:\n                    logger.warning(\n                        f\"No config section '{field.from_config}' found in \"\n                        f\"'{section_key}' for component field '{attr_name}' in {name}, \"\n                        f\"using inline kwargs only\"\n                    )\n                    kwargs = field.kwargs\n                else:\n                    kwargs = {**cfg_section, **field.kwargs}\n\n            wrapper: _DeviceComponent | _PresenterComponent | _ViewComponent\n            match field.layer:\n                case \"device\":\n                    wrapper = _DeviceComponent(\n                        field.cls, attr_name, field.alias, **kwargs\n                    )\n                    devices[attr_name] = wrapper\n                case \"presenter\":\n                    wrapper = _PresenterComponent(\n                        field.cls, attr_name, None, **kwargs\n                    )\n                    presenters[attr_name] = wrapper\n                case \"view\":\n                    wrapper = _ViewComponent(field.cls, attr_name, None, **kwargs)\n                    views[attr_name] = wrapper\n                case _:\n                    _assert_never(field.layer)\n            setattr(cls, attr_name, wrapper)\n\n    cls._device_components = devices\n    cls._presenter_components = presenters\n    cls._view_components = views\n\n    if devices or presenters or views:\n        logger.debug(\n            f\"Collected from {name}: \"\n            f\"{len(devices)} devices, \"\n            f\"{len(presenters)} presenters, \"\n            f\"{len(views)} views\"\n        )\n\n    return cls\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer","level":2,"title":"<code>AppContainer</code>","text":"<p>Application container for MVP architecture.</p> <p>Subclass this to define your application's components using the <code>component</code> field specifier.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>str</code> <p>Session name. Defaults to <code>\"Redsun\"</code>.</p> <code>'Redsun'</code> <code>frontend</code> <code>str</code> <p>Frontend type. Defaults to <code>\"pyqt\"</code>.</p> <code>'pyqt'</code> <p>Examples:</p> <p>Basic usage with inline kwargs:</p> <pre><code>&gt;&gt;&gt; class MyApp(AppContainer):\n...     motor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n...     ctrl = component(MyController, layer=\"presenter\")\n</code></pre> <p>With a configuration file:</p> <pre><code>&gt;&gt;&gt; class MyApp(AppContainer, config=\"app_config.yaml\"):\n...     motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n</code></pre> <p>Building and running:</p> <pre><code>&gt;&gt;&gt; app = MyApp(session=\"Experiment 1\")\n&gt;&gt;&gt; app.build()\n&gt;&gt;&gt; app.run()\n</code></pre> Source code in <code>src/redsun/containers/container.py</code> <pre><code>class AppContainer(metaclass=AppContainerMeta):\n    \"\"\"Application container for MVP architecture.\n\n    Subclass this to define your application's components using the\n    [`component`][redsun.containers.components.component] field specifier.\n\n    Parameters\n    ----------\n    session : str\n        Session name. Defaults to ``\"Redsun\"``.\n    frontend : str\n        Frontend type. Defaults to ``\"pyqt\"``.\n\n    Examples\n    --------\n    Basic usage with inline kwargs:\n\n    &gt;&gt;&gt; class MyApp(AppContainer):\n    ...     motor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n    ...     ctrl = component(MyController, layer=\"presenter\")\n\n    With a configuration file:\n\n    &gt;&gt;&gt; class MyApp(AppContainer, config=\"app_config.yaml\"):\n    ...     motor = component(MyMotor, layer=\"device\", from_config=\"motor\")\n\n    Building and running:\n\n    &gt;&gt;&gt; app = MyApp(session=\"Experiment 1\")\n    &gt;&gt;&gt; app.build()\n    &gt;&gt;&gt; app.run()\n    \"\"\"\n\n    _device_components: ClassVar[dict[str, _DeviceComponent]]\n    _presenter_components: ClassVar[dict[str, _PresenterComponent]]\n    _view_components: ClassVar[dict[str, _ViewComponent]]\n\n    __slots__ = (\n        \"_config\",\n        \"_virtual_bus\",\n        \"_di_container\",\n        \"_is_built\",\n    )\n\n    def __init__(self, *, session: str = \"Redsun\", frontend: str = \"pyqt\") -&gt; None:\n        self._config = {\n            \"session\": session,\n            \"frontend\": frontend,\n        }\n        self._virtual_bus: VirtualBus | None = None\n        self._di_container: containers.DynamicContainer | None = None\n        self._is_built: bool = False\n\n    @property\n    def config(self) -&gt; dict[str, Any]:\n        \"\"\"Return the configuration dictionary.\"\"\"\n        return self._config\n\n    @property\n    def devices(self) -&gt; dict[str, Device]:\n        \"\"\"Return built device instances.\n\n        Raises\n        ------\n        RuntimeError\n            If the container has not been built yet.\n        \"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {name: comp.instance for name, comp in self._device_components.items()}\n\n    @property\n    def presenters(self) -&gt; dict[str, Presenter]:\n        \"\"\"Return built presenter instances.\n\n        Raises\n        ------\n        RuntimeError\n            If the container has not been built yet.\n        \"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {\n            name: comp.instance for name, comp in self._presenter_components.items()\n        }\n\n    @property\n    def views(self) -&gt; dict[str, View]:\n        \"\"\"Return built view instances.\n\n        Raises\n        ------\n        RuntimeError\n            If the container has not been built yet.\n        \"\"\"\n        if not self._is_built:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return {name: comp.instance for name, comp in self._view_components.items()}\n\n    @property\n    def virtual_bus(self) -&gt; VirtualBus:\n        \"\"\"Return the virtual bus instance.\n\n        Raises\n        ------\n        RuntimeError\n            If the container has not been built yet.\n        \"\"\"\n        if self._virtual_bus is None:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return self._virtual_bus\n\n    @property\n    def di_container(self) -&gt; containers.DynamicContainer:\n        \"\"\"Return the dependency-injector container.\n\n        Raises\n        ------\n        RuntimeError\n            If the container has not been built yet.\n        \"\"\"\n        if self._di_container is None:\n            raise RuntimeError(\"Container not built. Call build() first.\")\n        return self._di_container\n\n    @property\n    def is_built(self) -&gt; bool:\n        \"\"\"Return whether the container has been built.\"\"\"\n        return self._is_built\n\n    def build(self) -&gt; AppContainer:\n        \"\"\"Instantiate all components in dependency order.\n\n        Build order:\n\n        1. VirtualBus\n        2. DI Container\n        3. Devices\n        4. Presenters (register their providers in the DI container)\n        5. Views (inject dependencies from the DI container)\n\n        Returns\n        -------\n        AppContainer\n            Self, for method chaining.\n        \"\"\"\n        if self._is_built:\n            logger.warning(\"Container already built, skipping rebuild\")\n            return self\n\n        logger.info(\"Building application container...\")\n\n        # 1. Virtual bus for runtime signals\n        self._virtual_bus = VirtualBus()\n        logger.debug(\"Virtual bus created\")\n\n        # 2. DI container for presenter -&gt; view injection\n        self._di_container = containers.DynamicContainer()\n        self._di_container.config = providers.Configuration()\n        self._di_container.config.from_dict(self._config)\n        logger.debug(\"DI container created\")\n\n        # build devices\n        built_devices: dict[str, Device] = {}\n        for name, device in self._device_components.items():\n            try:\n                built_devices[name] = device.build()\n                logger.debug(f\"Device '{name}' built\")\n            except Exception as e:\n                logger.error(f\"Failed to build device '{name}': {e}\")\n\n        # build presenters and register their providers\n        for name, presenter_component in self._presenter_components.items():\n            try:\n                presenter = presenter_component.build(built_devices, self._virtual_bus)\n                if isinstance(presenter, IsProvider):\n                    presenter.register_providers(self._di_container)\n            except Exception as e:\n                logger.error(f\"Failed to build presenter '{name}': {e}\")\n                raise\n\n        # build views and inject dependencies\n        for name, view_component in self._view_components.items():\n            try:\n                view = view_component.build(self._virtual_bus)\n                if isinstance(view, IsInjectable):\n                    view.inject_dependencies(self._di_container)\n            except Exception as e:\n                logger.error(f\"Failed to build view '{name}': {e}\")\n                raise\n\n        self._is_built = True\n        logger.info(\n            f\"Container built: \"\n            f\"{len(self._device_components)} devices, \"\n            f\"{len(self._presenter_components)} presenters, \"\n            f\"{len(self._view_components)} views\"\n        )\n\n        return self\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown all presenters that implement ``HasShutdown``.\"\"\"\n        if not self._is_built:\n            return\n\n        for name, comp in self._presenter_components.items():\n            if isinstance(comp.instance, HasShutdown):\n                try:\n                    comp.instance.shutdown()\n                except Exception as e:\n                    logger.error(f\"Error shutting down presenter '{name}': {e}\")\n\n        self._is_built = False\n        logger.info(\"Container shutdown complete\")\n\n    def run(self) -&gt; None:\n        \"\"\"Build if needed and start the application.\n\n        Subclasses override this to provide frontend-specific launch logic.\n        \"\"\"\n        if not self._is_built:\n            self.build()\n\n        frontend = self._config.get(\"frontend\", \"pyqt\")\n        logger.info(f\"Starting application with frontend: {frontend}\")\n\n    @classmethod\n    def from_config(cls, config_path: str) -&gt; AppContainer:\n        \"\"\"Build a container dynamically from a YAML configuration file.\n\n        Reads the configuration, discovers plugins via entry points,\n        and returns an unbuilt container of the appropriate frontend type.\n\n        Parameters\n        ----------\n        config_path : str\n            Path to the YAML configuration file.\n\n        Returns\n        -------\n        AppContainer\n            A configured (but unbuilt) container instance.\n        \"\"\"\n        config, plugin_types = cls._load_configuration(config_path)\n\n        namespace: dict[str, Any] = {}\n\n        # Create device components\n        for name, device_cfg in config.get(\"devices\", {}).items():\n            device_class = plugin_types[\"devices\"][name]\n            kwargs = {k: v for k, v in device_cfg.items() if k not in _PLUGIN_META_KEYS}\n            namespace[name] = _DeviceComponent(device_class, name, None, **kwargs)\n\n        # Create presenter components\n        for name, presenter_cfg in config.get(\"presenters\", {}).items():\n            presenter_class = plugin_types[\"presenters\"][name]\n            kwargs = {\n                k: v for k, v in presenter_cfg.items() if k not in _PLUGIN_META_KEYS\n            }\n            namespace[name] = _PresenterComponent(presenter_class, name, None, **kwargs)\n\n        # Create view components\n        for name, view_cfg in config.get(\"views\", {}).items():\n            view_class = plugin_types[\"views\"][name]\n            kwargs = {k: v for k, v in view_cfg.items() if k not in _PLUGIN_META_KEYS}\n            namespace[name] = _ViewComponent(view_class, name, None, **kwargs)\n\n        # Resolve the correct base class for the configured frontend\n        frontend = config.get(\"frontend\", \"pyqt\")\n        base_class = _resolve_frontend_container(frontend)\n\n        DynamicApp: type[AppContainer] = type(\"DynamicApp\", (base_class,), namespace)\n\n        return DynamicApp(\n            session=config.get(\"session\", \"Redsun\"),\n            frontend=frontend,\n        )\n\n    @classmethod\n    def _load_configuration(\n        cls, config_path: str\n    ) -&gt; tuple[dict[str, Any], _PluginTypeDict]:\n        \"\"\"Load configuration and discover plugin classes from a YAML file.\"\"\"\n        with open(config_path, \"r\") as f:\n            config: dict[str, Any] = yaml.safe_load(f)\n\n        plugin_types: _PluginTypeDict = {\"devices\": {}, \"presenters\": {}, \"views\": {}}\n        available_manifests = entry_points(group=\"redsun.plugins\")\n\n        groups: list[PLUGIN_GROUPS] = [\"devices\", \"presenters\", \"views\"]\n\n        for group in groups:\n            if group not in config:\n                logger.debug(\n                    \"Group %s not found in the configuration file. Skipping\", group\n                )\n                continue\n            loaded = cls._load_plugins(\n                group_cfg=config[group],\n                group=group,\n                available_manifests=available_manifests,\n            )\n            for name, plugin_cls in loaded:\n                # mypy complains because it can't verify the type of plugin_cls;\n                # but it is guaranteed to be correct at runtime because we're\n                # doing a lot of manual checks so just ignore it\n                plugin_types[group][name] = plugin_cls  # type: ignore[assignment]\n\n        return config, plugin_types\n\n    @classmethod\n    def _load_plugins(\n        cls,\n        *,\n        group_cfg: dict[str, Any],\n        group: PLUGIN_GROUPS,\n        available_manifests: EntryPoints,\n    ) -&gt; list[tuple[str, PluginType]]:\n        \"\"\"Load plugin classes for a given group.\"\"\"\n        plugins: list[tuple[str, PluginType]] = []\n\n        for name, info in group_cfg.items():\n            plugin_name: str = info[\"plugin_name\"]\n            plugin_id: str = info[\"plugin_id\"]\n\n            iterator = (\n                entry for entry in available_manifests if entry.name == plugin_name\n            )\n            plugin = next(iterator, None)\n\n            if plugin is None:\n                logger.error(\n                    'Plugin \"%s\" not found in the installed plugins.', plugin_name\n                )\n                continue\n\n            pkg_manifest = files(plugin.name.replace(\"-\", \"_\")) / plugin.value\n            with as_file(pkg_manifest) as manifest_path:\n                with open(manifest_path, \"r\") as f:\n                    manifest: dict[str, ManifestItems] = yaml.safe_load(f)\n\n                if group not in manifest:\n                    logger.error(\n                        'Plugin \"%s\" manifest does not contain group \"%s\".',\n                        plugin_name,\n                        group,\n                    )\n                    continue\n\n                items = manifest[group]\n                if plugin_id not in items:\n                    logger.error(\n                        'Plugin \"%s\" does not contain the id \"%s\".',\n                        plugin_name,\n                        plugin_id,\n                    )\n                    continue\n\n                item = items[plugin_id]\n                try:\n                    class_item_module, class_item_type = item[\"class\"].split(\":\")\n                    imported_class = getattr(\n                        import_module(class_item_module), class_item_type\n                    )\n                except KeyError:\n                    logger.error(\n                        'Plugin id \"%s\" of \"%s\" does not contain the class key. Skipping.',\n                        plugin_id,\n                        name,\n                    )\n                    continue\n\n                if not _check_plugin_protocol(imported_class, group):\n                    logger.error(\n                        \"%s exists, but does not implement any known protocol.\",\n                        imported_class,\n                    )\n                    continue\n\n                plugins.append((name, imported_class))\n\n        return plugins\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.config","level":3,"title":"<code>config</code>  <code>property</code>","text":"<p>Return the configuration dictionary.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.devices","level":3,"title":"<code>devices</code>  <code>property</code>","text":"<p>Return built device instances.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container has not been built yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.presenters","level":3,"title":"<code>presenters</code>  <code>property</code>","text":"<p>Return built presenter instances.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container has not been built yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.views","level":3,"title":"<code>views</code>  <code>property</code>","text":"<p>Return built view instances.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container has not been built yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.virtual_bus","level":3,"title":"<code>virtual_bus</code>  <code>property</code>","text":"<p>Return the virtual bus instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container has not been built yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.di_container","level":3,"title":"<code>di_container</code>  <code>property</code>","text":"<p>Return the dependency-injector container.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container has not been built yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.is_built","level":3,"title":"<code>is_built</code>  <code>property</code>","text":"<p>Return whether the container has been built.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.build","level":3,"title":"<code>build()</code>","text":"<p>Instantiate all components in dependency order.</p> <p>Build order:</p> <ol> <li>VirtualBus</li> <li>DI Container</li> <li>Devices</li> <li>Presenters (register their providers in the DI container)</li> <li>Views (inject dependencies from the DI container)</li> </ol> <p>Returns:</p> Type Description <code>AppContainer</code> <p>Self, for method chaining.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def build(self) -&gt; AppContainer:\n    \"\"\"Instantiate all components in dependency order.\n\n    Build order:\n\n    1. VirtualBus\n    2. DI Container\n    3. Devices\n    4. Presenters (register their providers in the DI container)\n    5. Views (inject dependencies from the DI container)\n\n    Returns\n    -------\n    AppContainer\n        Self, for method chaining.\n    \"\"\"\n    if self._is_built:\n        logger.warning(\"Container already built, skipping rebuild\")\n        return self\n\n    logger.info(\"Building application container...\")\n\n    # 1. Virtual bus for runtime signals\n    self._virtual_bus = VirtualBus()\n    logger.debug(\"Virtual bus created\")\n\n    # 2. DI container for presenter -&gt; view injection\n    self._di_container = containers.DynamicContainer()\n    self._di_container.config = providers.Configuration()\n    self._di_container.config.from_dict(self._config)\n    logger.debug(\"DI container created\")\n\n    # build devices\n    built_devices: dict[str, Device] = {}\n    for name, device in self._device_components.items():\n        try:\n            built_devices[name] = device.build()\n            logger.debug(f\"Device '{name}' built\")\n        except Exception as e:\n            logger.error(f\"Failed to build device '{name}': {e}\")\n\n    # build presenters and register their providers\n    for name, presenter_component in self._presenter_components.items():\n        try:\n            presenter = presenter_component.build(built_devices, self._virtual_bus)\n            if isinstance(presenter, IsProvider):\n                presenter.register_providers(self._di_container)\n        except Exception as e:\n            logger.error(f\"Failed to build presenter '{name}': {e}\")\n            raise\n\n    # build views and inject dependencies\n    for name, view_component in self._view_components.items():\n        try:\n            view = view_component.build(self._virtual_bus)\n            if isinstance(view, IsInjectable):\n                view.inject_dependencies(self._di_container)\n        except Exception as e:\n            logger.error(f\"Failed to build view '{name}': {e}\")\n            raise\n\n    self._is_built = True\n    logger.info(\n        f\"Container built: \"\n        f\"{len(self._device_components)} devices, \"\n        f\"{len(self._presenter_components)} presenters, \"\n        f\"{len(self._view_components)} views\"\n    )\n\n    return self\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.shutdown","level":3,"title":"<code>shutdown()</code>","text":"<p>Shutdown all presenters that implement <code>HasShutdown</code>.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown all presenters that implement ``HasShutdown``.\"\"\"\n    if not self._is_built:\n        return\n\n    for name, comp in self._presenter_components.items():\n        if isinstance(comp.instance, HasShutdown):\n            try:\n                comp.instance.shutdown()\n            except Exception as e:\n                logger.error(f\"Error shutting down presenter '{name}': {e}\")\n\n    self._is_built = False\n    logger.info(\"Container shutdown complete\")\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.run","level":3,"title":"<code>run()</code>","text":"<p>Build if needed and start the application.</p> <p>Subclasses override this to provide frontend-specific launch logic.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Build if needed and start the application.\n\n    Subclasses override this to provide frontend-specific launch logic.\n    \"\"\"\n    if not self._is_built:\n        self.build()\n\n    frontend = self._config.get(\"frontend\", \"pyqt\")\n    logger.info(f\"Starting application with frontend: {frontend}\")\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.containers.container.AppContainer.from_config","level":3,"title":"<code>from_config(config_path)</code>  <code>classmethod</code>","text":"<p>Build a container dynamically from a YAML configuration file.</p> <p>Reads the configuration, discovers plugins via entry points, and returns an unbuilt container of the appropriate frontend type.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to the YAML configuration file.</p> required <p>Returns:</p> Type Description <code>AppContainer</code> <p>A configured (but unbuilt) container instance.</p> Source code in <code>src/redsun/containers/container.py</code> <pre><code>@classmethod\ndef from_config(cls, config_path: str) -&gt; AppContainer:\n    \"\"\"Build a container dynamically from a YAML configuration file.\n\n    Reads the configuration, discovers plugins via entry points,\n    and returns an unbuilt container of the appropriate frontend type.\n\n    Parameters\n    ----------\n    config_path : str\n        Path to the YAML configuration file.\n\n    Returns\n    -------\n    AppContainer\n        A configured (but unbuilt) container instance.\n    \"\"\"\n    config, plugin_types = cls._load_configuration(config_path)\n\n    namespace: dict[str, Any] = {}\n\n    # Create device components\n    for name, device_cfg in config.get(\"devices\", {}).items():\n        device_class = plugin_types[\"devices\"][name]\n        kwargs = {k: v for k, v in device_cfg.items() if k not in _PLUGIN_META_KEYS}\n        namespace[name] = _DeviceComponent(device_class, name, None, **kwargs)\n\n    # Create presenter components\n    for name, presenter_cfg in config.get(\"presenters\", {}).items():\n        presenter_class = plugin_types[\"presenters\"][name]\n        kwargs = {\n            k: v for k, v in presenter_cfg.items() if k not in _PLUGIN_META_KEYS\n        }\n        namespace[name] = _PresenterComponent(presenter_class, name, None, **kwargs)\n\n    # Create view components\n    for name, view_cfg in config.get(\"views\", {}).items():\n        view_class = plugin_types[\"views\"][name]\n        kwargs = {k: v for k, v in view_cfg.items() if k not in _PLUGIN_META_KEYS}\n        namespace[name] = _ViewComponent(view_class, name, None, **kwargs)\n\n    # Resolve the correct base class for the configured frontend\n    frontend = config.get(\"frontend\", \"pyqt\")\n    base_class = _resolve_frontend_container(frontend)\n\n    DynamicApp: type[AppContainer] = type(\"DynamicApp\", (base_class,), namespace)\n\n    return DynamicApp(\n        session=config.get(\"session\", \"Redsun\"),\n        frontend=frontend,\n    )\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer","level":2,"title":"<code>QtAppContainer</code>","text":"<p>               Bases: <code>AppContainer</code></p> <p>Application container for Qt-based frontends.</p> <p>Handles the full Qt lifecycle: <code>QApplication</code> creation, container build, <code>QtMainView</code> construction, virtual bus connection, and <code>app.exec()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**config</code> <code>Any</code> <p>Configuration options passed to :meth:<code>AppContainer.__init__</code>.</p> <code>{}</code> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>class QtAppContainer(AppContainer):\n    \"\"\"Application container for Qt-based frontends.\n\n    Handles the full Qt lifecycle: ``QApplication`` creation, container\n    build, ``QtMainView`` construction, virtual bus connection, and\n    ``app.exec()``.\n\n    Parameters\n    ----------\n    **config : Any\n        Configuration options passed to :meth:`AppContainer.__init__`.\n    \"\"\"\n\n    __slots__ = (\"_qt_app\", \"_main_view\")\n\n    def __init__(self, **config: Any) -&gt; None:\n        super().__init__(**config)\n        self._qt_app: QApplication | None = None\n        self._main_view: QtMainView | None = None\n\n    @property\n    def main_view(self) -&gt; QtMainView:\n        \"\"\"Return the main Qt window.\n\n        Raises\n        ------\n        RuntimeError\n            If the application has not been run yet.\n        \"\"\"\n        if self._main_view is None:\n            raise RuntimeError(\"Main view not built. Call run() first.\")\n        return self._main_view\n\n    def build(self) -&gt; QtAppContainer:\n        \"\"\"Ensure a ``QApplication`` exists, then build all components.\n\n        If a ``QApplication`` is not yet running (e.g. when ``build()`` is\n        called explicitly before ``run()``), one is created here so that\n        view components that instantiate ``QWidget`` subclasses have a valid\n        application object available.\n        \"\"\"\n        if self._qt_app is None:\n            self._qt_app = cast(\n                \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n            )\n        super().build()\n        return self\n\n    def run(self) -&gt; NoReturn:\n        \"\"\"Build and launch the Qt application.\"\"\"\n        if self._qt_app is None:\n            self._qt_app = cast(\n                \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n            )\n\n        if not self.is_built:\n            self.build()\n\n        assert self._qt_app is not None  # guaranteed by build() above\n        session_name = self._config.get(\"session\", \"Redsun\")\n        self._main_view = QtMainView(\n            virtual_bus=self.virtual_bus,\n            session_name=session_name,\n            views=cast(\"dict[str, QtView]\", self.views),\n        )\n\n        # 4. Connect virtual bus\n        self._main_view.connect_to_virtual()\n\n        # 5. Wire shutdown and start psygnal bridge\n        self._qt_app.aboutToQuit.connect(self.shutdown)\n        start_emitting_from_queue()\n\n        # 6. Show and exec\n        self._main_view.show()\n        sys.exit(self._qt_app.exec())\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.main_view","level":3,"title":"<code>main_view</code>  <code>property</code>","text":"<p>Return the main Qt window.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application has not been run yet.</p>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.build","level":3,"title":"<code>build()</code>","text":"<p>Ensure a <code>QApplication</code> exists, then build all components.</p> <p>If a <code>QApplication</code> is not yet running (e.g. when <code>build()</code> is called explicitly before <code>run()</code>), one is created here so that view components that instantiate <code>QWidget</code> subclasses have a valid application object available.</p> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>def build(self) -&gt; QtAppContainer:\n    \"\"\"Ensure a ``QApplication`` exists, then build all components.\n\n    If a ``QApplication`` is not yet running (e.g. when ``build()`` is\n    called explicitly before ``run()``), one is created here so that\n    view components that instantiate ``QWidget`` subclasses have a valid\n    application object available.\n    \"\"\"\n    if self._qt_app is None:\n        self._qt_app = cast(\n            \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n        )\n    super().build()\n    return self\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/api/#redsun.qt.QtAppContainer.run","level":3,"title":"<code>run()</code>","text":"<p>Build and launch the Qt application.</p> Source code in <code>src/redsun/containers/qt/_container.py</code> <pre><code>def run(self) -&gt; NoReturn:\n    \"\"\"Build and launch the Qt application.\"\"\"\n    if self._qt_app is None:\n        self._qt_app = cast(\n            \"QApplication\", QApplication.instance() or QApplication(sys.argv)\n        )\n\n    if not self.is_built:\n        self.build()\n\n    assert self._qt_app is not None  # guaranteed by build() above\n    session_name = self._config.get(\"session\", \"Redsun\")\n    self._main_view = QtMainView(\n        virtual_bus=self.virtual_bus,\n        session_name=session_name,\n        views=cast(\"dict[str, QtView]\", self.views),\n    )\n\n    # 4. Connect virtual bus\n    self._main_view.connect_to_virtual()\n\n    # 5. Wire shutdown and start psygnal bridge\n    self._qt_app.aboutToQuit.connect(self.shutdown)\n    start_emitting_from_queue()\n\n    # 6. Show and exec\n    self._main_view.show()\n    sys.exit(self._qt_app.exec())\n</code></pre>","path":["API reference"],"tags":[]},{"location":"reference/changelog/","level":1,"title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Dates are specified in the format <code>DD-MM-YYYY</code>.</p>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#055-18-02-2026","level":2,"title":"0.5.5 - 18-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added","level":3,"title":"Added","text":"<ul> <li><code>redsun.qt</code> public namespace exposing <code>QtAppContainer</code> for use in explicit,   developer-written application configurations:   <pre><code>from redsun.qt import QtAppContainer\n</code></pre></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#054-18-02-2026","level":2,"title":"0.5.4 - 18-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#fixed","level":3,"title":"Fixed","text":"<ul> <li>Relaxed the <code>component()</code> overloads: all three (<code>layer=\"device\"</code>, <code>layer=\"presenter\"</code>,   <code>layer=\"view\"</code>) now accept <code>type</code> instead of <code>type[Device]</code>, <code>type[Presenter]</code>,   <code>type[View]</code>. This fixes mypy errors for classes built from protocol mixins that do   not inherit from the sunflare base classes directly.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#053-18-02-2026","level":2,"title":"0.5.3 - 18-02-2026","text":"<p>Warning</p> <p>This release was yanked from PyPI due to a broken distribution</p>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added_1","level":3,"title":"Added","text":"<ul> <li><code>AppContainer</code> and <code>component</code> are now importable directly from the top-level   <code>redsun</code> package:   <pre><code>from redsun import AppContainer, component\n</code></pre></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed","level":3,"title":"Changed","text":"<ul> <li><code>component()</code> now takes the component class as its first positional argument:   <pre><code># Before\nmotor: MyMotor = component(layer=\"device\", axis=[\"X\"])\n# After\nmotor = component(MyMotor, layer=\"device\", axis=[\"X\"])\n</code></pre></li> <li><code>RedSunConfig</code> removed from the public API; it is an internal <code>TypedDict</code> used   only for YAML configuration validation.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#050-17-02-2026","level":2,"title":"0.5.0 - 17-02-2026","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_1","level":3,"title":"Changed","text":"<ul> <li>Fully refactor the package to go towards a containerization approach</li> <li>Declare applications as containers, list relevant components as fields of a class</li> <li>Provide support also for building from a configuration file as before</li> <li>Upgrade to <code>sunflare&gt;=0.9.0</code></li> <li>Move the <code>FrontendTypes</code> and <code>ViewPositionTypes</code> from <code>sunflare</code> to <code>redsun</code></li> <li>They're part of the overall configuration and should not concern the core package</li> <li>Revamped documentation with more comprehensive information</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#040-15-12-2025","level":2,"title":"0.4.0 - 15-12-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_2","level":3,"title":"Changed","text":"<ul> <li>Apply a more strict check on imported plugins</li> <li>Add support for 3.13 (simply declared on PyPI and tested via CI)</li> <li>Upgrade to <code>sunflare&gt;=0.7.0</code></li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#030-04-07-2025","level":2,"title":"0.3.0 - 04-07-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_3","level":3,"title":"Changed","text":"<ul> <li>Upgraded to <code>sunflare&gt;=0.6.1</code></li> <li>Switch to <code>uv</code></li> <li>Drop support for Python 3.9</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#020-03-03-2025","level":2,"title":"0.2.0 - 03-03-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#changed_4","level":3,"title":"Changed","text":"<ul> <li>Reworked the plugin system</li> <li>The approach now loosely follows the <code>napari</code> manifest, where plugins are to be published via a <code>yaml</code> configuration file in the root folder of the plugin package, specifiying where the classes have to be imported.</li> <li>The manifest is taken as the actual entry point of a plugin, which will be used to redirect to the actual imports which is executed via the standard library <code>importlib</code>.</li> <li>Added additional coverage for the <code>factory</code> module.</li> <li>Bumped sunflare version to <code>sunflare&gt;=0.5.0</code>, which implements the above changes at toolkit level</li> </ul>","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#010-22-02-2025","level":2,"title":"0.1.0 - 22-02-2025","text":"","path":["Changelog"],"tags":[]},{"location":"reference/changelog/#added_2","level":3,"title":"Added","text":"<ul> <li>Initial release on PyPI</li> </ul>","path":["Changelog"],"tags":[]},{"location":"tutorials/","level":1,"title":"Tutorials","text":"<p>Tutorials are learning-oriented lessons that take you through a series of steps to complete a project or understand a concept. They are designed for beginners and those new to Redsun.</p>","path":["Tutorials"],"tags":[]},{"location":"tutorials/#available-tutorials","level":2,"title":"Available tutorials","text":"<p>Tutorials are coming soon.</p>","path":["Tutorials"],"tags":[]},{"location":"tutorials/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Check out the How-to guides for practical solutions to specific problems</li> <li>Read the Explanation section to deepen your understanding of Redsun's architecture</li> <li>Refer to the API reference for detailed technical information</li> </ul>","path":["Tutorials"],"tags":[]}]}